[assembly: System.Reflection.AssemblyMetadata("RepositoryUrl", "https://github.com/AwesomeAssertions/AwesomeAssertions")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"AwesomeAssertions.Equivalency.Specs, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"AwesomeAssertions.Specs, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"Benchmarks, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f")]
namespace AwesomeAssertions
{
    public class AggregateExceptionExtractor : AwesomeAssertions.Specialized.IExtractExceptions
    {
        public AggregateExceptionExtractor() { }
        public System.Collections.Generic.IEnumerable<T> OfType<T>(System.Exception actualException)
            where T : System.Exception { }
    }
    public class AndConstraint<TParent>
    {
        public AndConstraint(TParent parent) { }
        public TParent And { get; }
    }
    public class AndWhichConstraint<TParent, TSubject> : AwesomeAssertions.AndConstraint<TParent>
    {
        public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects) { }
        public AndWhichConstraint(TParent parent, TSubject subject) { }
        public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects, AwesomeAssertions.Execution.AssertionChain assertionChain, string pathPostfix) { }
        public AndWhichConstraint(TParent parent, TSubject subject, AwesomeAssertions.Execution.AssertionChain assertionChain, string pathPostfix = "") { }
        public TSubject Subject { get; }
        public TSubject Which { get; }
    }
    public static class AssertionConfiguration
    {
        public static AwesomeAssertions.Configuration.GlobalConfiguration Current { get; }
    }
    public static class AssertionEngine
    {
        public static AwesomeAssertions.Configuration.GlobalConfiguration Configuration { get; }
        public static AwesomeAssertions.Execution.ITestFramework TestFramework { get; set; }
        public static void ResetToDefaults() { }
    }
    public static class AssertionExtensions
    {
        public static TTo As<TTo>(this object subject) { }
        public static System.Func<System.Threading.Tasks.Task> Awaiting<T>(this T subject, System.Func<T, System.Threading.Tasks.Task> action) { }
        public static System.Func<System.Threading.Tasks.Task> Awaiting<T>(this T subject, System.Func<T, System.Threading.Tasks.ValueTask> action) { }
        public static System.Func<System.Threading.Tasks.Task<TResult>> Awaiting<T, TResult>(this T subject, System.Func<T, System.Threading.Tasks.Task<TResult>> action) { }
        public static System.Func<System.Threading.Tasks.Task<TResult>> Awaiting<T, TResult>(this T subject, System.Func<T, System.Threading.Tasks.ValueTask<TResult>> action) { }
        public static System.Action Enumerating(this System.Func<System.Collections.IEnumerable> enumerable) { }
        public static System.Action Enumerating<T>(this System.Func<System.Collections.Generic.IEnumerable<T>> enumerable) { }
        public static System.Action Enumerating<T, TResult>(this T subject, System.Func<T, System.Collections.Generic.IEnumerable<TResult>> enumerable) { }
        public static AwesomeAssertions.Specialized.ExecutionTime ExecutionTime(this System.Func<System.Threading.Tasks.Task> action) { }
        public static AwesomeAssertions.Specialized.ExecutionTime ExecutionTime(this System.Action action, AwesomeAssertions.Common.StartTimer createTimer = null) { }
        public static AwesomeAssertions.Specialized.MemberExecutionTime<T> ExecutionTimeOf<T>(this T subject, System.Linq.Expressions.Expression<System.Action<T>> action, AwesomeAssertions.Common.StartTimer createTimer = null) { }
        public static System.Action Invoking<T>(this T subject, System.Action<T> action) { }
        public static System.Func<TResult> Invoking<T, TResult>(this T subject, System.Func<T, TResult> action) { }
        public static AwesomeAssertions.Events.IMonitor<T> Monitor<T>(this T eventSource) { }
        public static AwesomeAssertions.Events.IMonitor<T> Monitor<T>(this T eventSource, System.Action<AwesomeAssertions.Events.EventMonitorOptions> configureOptions) { }
        public static AwesomeAssertions.Specialized.ExecutionTimeAssertions Should(this AwesomeAssertions.Specialized.ExecutionTime executionTime) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this AwesomeAssertions.Specialized.ExecutionTimeAssertions _) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this AwesomeAssertions.Specialized.TaskCompletionSourceAssertionsBase _) { }
        public static AwesomeAssertions.Types.MethodInfoSelectorAssertions Should(this AwesomeAssertions.Types.MethodInfoSelector methodSelector) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this AwesomeAssertions.Types.MethodInfoSelectorAssertions _) { }
        public static AwesomeAssertions.Types.PropertyInfoSelectorAssertions Should(this AwesomeAssertions.Types.PropertyInfoSelector propertyInfoSelector) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this AwesomeAssertions.Types.PropertyInfoSelectorAssertions _) { }
        public static AwesomeAssertions.Types.TypeSelectorAssertions Should(this AwesomeAssertions.Types.TypeSelector typeSelector) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should(this AwesomeAssertions.Types.TypeSelectorAssertions _) { }
        public static AwesomeAssertions.Specialized.ActionAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Action action) { }
        public static AwesomeAssertions.Collections.StringCollectionAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IEnumerable<string> @this) { }
        public static AwesomeAssertions.Primitives.DateOnlyAssertions Should(this System.DateOnly actualValue) { }
        public static AwesomeAssertions.Primitives.NullableDateOnlyAssertions Should(this System.DateOnly? actualValue) { }
        public static AwesomeAssertions.Primitives.DateTimeAssertions Should(this System.DateTime actualValue) { }
        public static AwesomeAssertions.Primitives.NullableDateTimeAssertions Should(this System.DateTime? actualValue) { }
        public static AwesomeAssertions.Primitives.DateTimeOffsetAssertions Should(this System.DateTimeOffset actualValue) { }
        public static AwesomeAssertions.Primitives.NullableDateTimeOffsetAssertions Should(this System.DateTimeOffset? actualValue) { }
        public static AwesomeAssertions.Specialized.NonGenericAsyncFunctionAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Func<System.Threading.Tasks.Task> action) { }
        public static AwesomeAssertions.Primitives.GuidAssertions Should(this System.Guid actualValue) { }
        public static AwesomeAssertions.Primitives.NullableGuidAssertions Should(this System.Guid? actualValue) { }
        public static AwesomeAssertions.Streams.BufferedStreamAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.IO.BufferedStream actualValue) { }
        public static AwesomeAssertions.Streams.StreamAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.IO.Stream actualValue) { }
        public static AwesomeAssertions.Types.AssemblyAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.Assembly assembly) { }
        public static AwesomeAssertions.Types.ConstructorInfoAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.ConstructorInfo constructorInfo) { }
        public static AwesomeAssertions.Types.MethodInfoAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.MethodInfo methodInfo) { }
        public static AwesomeAssertions.Types.PropertyInfoAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.PropertyInfo propertyInfo) { }
        public static AwesomeAssertions.Specialized.TaskCompletionSourceAssertions Should(this System.Threading.Tasks.TaskCompletionSource tcs) { }
        public static AwesomeAssertions.Primitives.TimeOnlyAssertions Should(this System.TimeOnly actualValue) { }
        public static AwesomeAssertions.Primitives.NullableTimeOnlyAssertions Should(this System.TimeOnly? actualValue) { }
        public static AwesomeAssertions.Primitives.SimpleTimeSpanAssertions Should(this System.TimeSpan actualValue) { }
        public static AwesomeAssertions.Primitives.NullableSimpleTimeSpanAssertions Should(this System.TimeSpan? actualValue) { }
        public static AwesomeAssertions.Types.TypeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Type subject) { }
        public static AwesomeAssertions.Xml.XAttributeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XAttribute actualValue) { }
        public static AwesomeAssertions.Xml.XDocumentAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XDocument actualValue) { }
        public static AwesomeAssertions.Xml.XElementAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XElement actualValue) { }
        public static AwesomeAssertions.Primitives.BooleanAssertions Should(this bool actualValue) { }
        public static AwesomeAssertions.Primitives.NullableBooleanAssertions Should(this bool? actualValue) { }
        public static AwesomeAssertions.Numeric.NumericAssertions<byte> Should(this byte actualValue) { }
        public static AwesomeAssertions.Numeric.NullableNumericAssertions<byte> Should(this byte? actualValue) { }
        public static AwesomeAssertions.Numeric.NumericAssertions<decimal> Should(this decimal actualValue) { }
        public static AwesomeAssertions.Numeric.NullableNumericAssertions<decimal> Should(this decimal? actualValue) { }
        public static AwesomeAssertions.Numeric.NumericAssertions<double> Should(this double actualValue) { }
        public static AwesomeAssertions.Numeric.NullableNumericAssertions<double> Should(this double? actualValue) { }
        public static AwesomeAssertions.Numeric.NumericAssertions<float> Should(this float actualValue) { }
        public static AwesomeAssertions.Numeric.NullableNumericAssertions<float> Should(this float? actualValue) { }
        public static AwesomeAssertions.Numeric.NumericAssertions<int> Should(this int actualValue) { }
        public static AwesomeAssertions.Numeric.NullableNumericAssertions<int> Should(this int? actualValue) { }
        public static AwesomeAssertions.Numeric.NumericAssertions<long> Should(this long actualValue) { }
        public static AwesomeAssertions.Numeric.NullableNumericAssertions<long> Should(this long? actualValue) { }
        public static AwesomeAssertions.Primitives.ObjectAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this object actualValue) { }
        public static AwesomeAssertions.Numeric.NumericAssertions<sbyte> Should(this sbyte actualValue) { }
        public static AwesomeAssertions.Numeric.NullableNumericAssertions<sbyte> Should(this sbyte? actualValue) { }
        public static AwesomeAssertions.Numeric.NumericAssertions<short> Should(this short actualValue) { }
        public static AwesomeAssertions.Numeric.NullableNumericAssertions<short> Should(this short? actualValue) { }
        public static AwesomeAssertions.Primitives.StringAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this string actualValue) { }
        public static AwesomeAssertions.Numeric.NumericAssertions<uint> Should(this uint actualValue) { }
        public static AwesomeAssertions.Numeric.NullableNumericAssertions<uint> Should(this uint? actualValue) { }
        public static AwesomeAssertions.Numeric.NumericAssertions<ulong> Should(this ulong actualValue) { }
        public static AwesomeAssertions.Numeric.NullableNumericAssertions<ulong> Should(this ulong? actualValue) { }
        public static AwesomeAssertions.Numeric.NumericAssertions<ushort> Should(this ushort actualValue) { }
        public static AwesomeAssertions.Numeric.NullableNumericAssertions<ushort> Should(this ushort? actualValue) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this AwesomeAssertions.Primitives.BooleanAssertions<TAssertions> _)
            where TAssertions : AwesomeAssertions.Primitives.BooleanAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this AwesomeAssertions.Primitives.DateOnlyAssertions<TAssertions> _)
            where TAssertions : AwesomeAssertions.Primitives.DateOnlyAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this AwesomeAssertions.Primitives.DateTimeAssertions<TAssertions> _)
            where TAssertions : AwesomeAssertions.Primitives.DateTimeAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this AwesomeAssertions.Primitives.DateTimeOffsetAssertions<TAssertions> _)
            where TAssertions : AwesomeAssertions.Primitives.DateTimeOffsetAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this AwesomeAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> _)
            where TAssertions : AwesomeAssertions.Primitives.DateTimeOffsetAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this AwesomeAssertions.Primitives.DateTimeRangeAssertions<TAssertions> _)
            where TAssertions : AwesomeAssertions.Primitives.DateTimeAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this AwesomeAssertions.Primitives.GuidAssertions<TAssertions> _)
            where TAssertions : AwesomeAssertions.Primitives.GuidAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this AwesomeAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions> _)
            where TAssertions : AwesomeAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TAssertions>(this AwesomeAssertions.Primitives.TimeOnlyAssertions<TAssertions> _)
            where TAssertions : AwesomeAssertions.Primitives.TimeOnlyAssertions<TAssertions> { }
        public static AwesomeAssertions.Collections.GenericCollectionAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IEnumerable<T> actualValue) { }
        public static AwesomeAssertions.Specialized.GenericAsyncFunctionAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.Func<System.Threading.Tasks.Task<T>> action) { }
        public static AwesomeAssertions.Specialized.FunctionAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.Func<T> func) { }
        public static AwesomeAssertions.Numeric.ComparableTypeAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.IComparable<T> comparableValue) { }
        public static AwesomeAssertions.Specialized.TaskCompletionSourceAssertions<T> Should<T>(this System.Threading.Tasks.TaskCompletionSource<T> tcs) { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TSubject, TAssertions>(this AwesomeAssertions.Numeric.NumericAssertionsBase<TSubject, TSubject, TAssertions> _)
            where TSubject :  struct, System.IComparable<TSubject>
            where TAssertions : AwesomeAssertions.Numeric.NumericAssertions<TSubject, TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TEnum, TAssertions>(this AwesomeAssertions.Primitives.EnumAssertions<TEnum, TAssertions> _)
            where TEnum :  struct, System.Enum
            where TAssertions : AwesomeAssertions.Primitives.EnumAssertions<TEnum, TAssertions> { }
        [System.Obsolete("You are asserting the \'AndConstraint\' itself. Remove the \'Should()\' method direct" +
            "ly following \'And\'", true)]
        public static void Should<TSubject, TAssertions>(this AwesomeAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions> _)
            where TAssertions : AwesomeAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions> { }
        public static AwesomeAssertions.Collections.GenericDictionaryAssertions<System.Collections.Generic.IDictionary<TKey, TValue>, TKey, TValue> Should<TKey, TValue>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IDictionary<TKey, TValue> actualValue) { }
        public static AwesomeAssertions.Collections.GenericDictionaryAssertions<System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, TKey, TValue> Should<TKey, TValue>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> actualValue) { }
        public static AwesomeAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue> Should<TCollection, TKey, TValue>([System.Diagnostics.CodeAnalysis.NotNull] this TCollection actualValue)
            where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }
    }
    public static class AsyncAssertionsExtensions
    {
        public static System.Threading.Tasks.Task<AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Specialized.GenericAsyncFunctionAssertions<T>, T>> WithResult<T>(this System.Threading.Tasks.Task<AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Specialized.GenericAsyncFunctionAssertions<T>, T>> task, T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static System.Threading.Tasks.Task<AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> WithResult<T>(this System.Threading.Tasks.Task<AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> task, T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public static class AtLeast
    {
        public static AwesomeAssertions.OccurrenceConstraint Once() { }
        public static AwesomeAssertions.OccurrenceConstraint Thrice() { }
        public static AwesomeAssertions.OccurrenceConstraint Times(int expected) { }
        public static AwesomeAssertions.OccurrenceConstraint Twice() { }
    }
    public static class AtMost
    {
        public static AwesomeAssertions.OccurrenceConstraint Once() { }
        public static AwesomeAssertions.OccurrenceConstraint Thrice() { }
        public static AwesomeAssertions.OccurrenceConstraint Times(int expected) { }
        public static AwesomeAssertions.OccurrenceConstraint Twice() { }
    }
    public static class CallerIdentifier
    {
        public static System.Action<string> Logger { get; set; }
        public static string DetermineCallerIdentity() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public class CustomAssertionAttribute : System.Attribute
    {
        public CustomAssertionAttribute() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly)]
    public sealed class CustomAssertionsAssemblyAttribute : System.Attribute
    {
        public CustomAssertionsAssemblyAttribute() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public sealed class CustomAssertionsAttribute : System.Attribute
    {
        public CustomAssertionsAttribute() { }
    }
    public static class EnumAssertionsExtensions
    {
        public static AwesomeAssertions.Primitives.EnumAssertions<TEnum> Should<TEnum>(this TEnum @enum)
            where TEnum :  struct, System.Enum { }
        public static AwesomeAssertions.Primitives.NullableEnumAssertions<TEnum> Should<TEnum>(this TEnum? @enum)
            where TEnum :  struct, System.Enum { }
    }
    public static class EventRaisingExtensions
    {
        public static AwesomeAssertions.Events.IEventRecording WithArgs<T>(this AwesomeAssertions.Events.IEventRecording eventRecording, System.Linq.Expressions.Expression<System.Func<T, bool>> predicate) { }
        public static AwesomeAssertions.Events.IEventRecording WithArgs<T>(this AwesomeAssertions.Events.IEventRecording eventRecording, params System.Linq.Expressions.Expression<System.Func<T, bool>>[] predicates) { }
        public static AwesomeAssertions.Events.IEventRecording WithSender(this AwesomeAssertions.Events.IEventRecording eventRecording, object expectedSender) { }
    }
    public static class Exactly
    {
        public static AwesomeAssertions.OccurrenceConstraint Once() { }
        public static AwesomeAssertions.OccurrenceConstraint Thrice() { }
        public static AwesomeAssertions.OccurrenceConstraint Times(int expected) { }
        public static AwesomeAssertions.OccurrenceConstraint Twice() { }
    }
    public static class ExceptionAssertionsExtensions
    {
        public static System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TException>> Where<TException>(this System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TException>> task, System.Linq.Expressions.Expression<System.Func<TException, bool>> exceptionExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public static System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<System.Exception>> WithInnerException<TException>(this System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TException>> task, System.Type innerException, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public static System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TInnerException>> WithInnerException<TException, TInnerException>(this System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TException>> task, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.Exception
            where TInnerException : System.Exception { }
        public static System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<System.Exception>> WithInnerExceptionExactly<TException>(this System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TException>> task, System.Type innerException, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public static System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TInnerException>> WithInnerExceptionExactly<TException, TInnerException>(this System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TException>> task, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.Exception
            where TInnerException : System.Exception { }
        public static System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TException>> WithMessage<TException>(this System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TException>> task, string expectedWildcardPattern, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public static AwesomeAssertions.Specialized.ExceptionAssertions<TException> WithParameterName<TException>(this AwesomeAssertions.Specialized.ExceptionAssertions<TException> parent, string paramName, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.ArgumentException { }
        public static System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TException>> WithParameterName<TException>(this System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TException>> task, string paramName, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.ArgumentException { }
    }
    public static class FluentActions
    {
        public static System.Func<System.Threading.Tasks.Task> Awaiting(System.Func<System.Threading.Tasks.Task> action) { }
        public static System.Func<System.Threading.Tasks.Task<T>> Awaiting<T>(System.Func<System.Threading.Tasks.Task<T>> func) { }
        public static System.Action Enumerating(System.Func<System.Collections.IEnumerable> enumerable) { }
        public static System.Action Enumerating<T>(System.Func<System.Collections.Generic.IEnumerable<T>> enumerable) { }
        public static System.Action Invoking(System.Action action) { }
        public static System.Func<T> Invoking<T>(System.Func<T> func) { }
    }
    public static class LessThan
    {
        public static AwesomeAssertions.OccurrenceConstraint Thrice() { }
        public static AwesomeAssertions.OccurrenceConstraint Times(int expected) { }
        public static AwesomeAssertions.OccurrenceConstraint Twice() { }
    }
    public static class MoreThan
    {
        public static AwesomeAssertions.OccurrenceConstraint Once() { }
        public static AwesomeAssertions.OccurrenceConstraint Thrice() { }
        public static AwesomeAssertions.OccurrenceConstraint Times(int expected) { }
        public static AwesomeAssertions.OccurrenceConstraint Twice() { }
    }
    public static class NumericAssertionsExtensions
    {
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<decimal>> BeApproximately(this AwesomeAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal expectedValue, decimal precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<decimal>> BeApproximately(this AwesomeAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal? expectedValue, decimal precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<double>> BeApproximately(this AwesomeAssertions.Numeric.NullableNumericAssertions<double> parent, double expectedValue, double precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<double>> BeApproximately(this AwesomeAssertions.Numeric.NullableNumericAssertions<double> parent, double? expectedValue, double precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<float>> BeApproximately(this AwesomeAssertions.Numeric.NullableNumericAssertions<float> parent, float expectedValue, float precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<float>> BeApproximately(this AwesomeAssertions.Numeric.NullableNumericAssertions<float> parent, float? expectedValue, float precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<decimal>> BeApproximately(this AwesomeAssertions.Numeric.NumericAssertions<decimal> parent, decimal expectedValue, decimal precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<double>> BeApproximately(this AwesomeAssertions.Numeric.NumericAssertions<double> parent, double expectedValue, double precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<float>> BeApproximately(this AwesomeAssertions.Numeric.NumericAssertions<float> parent, float expectedValue, float precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<byte>> BeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<byte> parent, byte nearbyValue, byte delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<int>> BeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<int> parent, int nearbyValue, uint delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<long>> BeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<long> parent, long nearbyValue, ulong delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<sbyte>> BeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<sbyte> parent, sbyte nearbyValue, byte delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<short>> BeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<short> parent, short nearbyValue, ushort delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<uint>> BeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<uint> parent, uint nearbyValue, uint delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<ulong>> BeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<ulong> parent, ulong nearbyValue, ulong delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<ushort>> BeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<ushort> parent, ushort nearbyValue, ushort delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<double>> BeNaN(this AwesomeAssertions.Numeric.NullableNumericAssertions<double> parent, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<float>> BeNaN(this AwesomeAssertions.Numeric.NullableNumericAssertions<float> parent, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<double>> BeNaN(this AwesomeAssertions.Numeric.NumericAssertions<double> parent, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<float>> BeNaN(this AwesomeAssertions.Numeric.NumericAssertions<float> parent, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<decimal>> NotBeApproximately(this AwesomeAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<decimal>> NotBeApproximately(this AwesomeAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal? unexpectedValue, decimal precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<double>> NotBeApproximately(this AwesomeAssertions.Numeric.NullableNumericAssertions<double> parent, double unexpectedValue, double precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<double>> NotBeApproximately(this AwesomeAssertions.Numeric.NullableNumericAssertions<double> parent, double? unexpectedValue, double precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<float>> NotBeApproximately(this AwesomeAssertions.Numeric.NullableNumericAssertions<float> parent, float unexpectedValue, float precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<float>> NotBeApproximately(this AwesomeAssertions.Numeric.NullableNumericAssertions<float> parent, float? unexpectedValue, float precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<decimal>> NotBeApproximately(this AwesomeAssertions.Numeric.NumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<double>> NotBeApproximately(this AwesomeAssertions.Numeric.NumericAssertions<double> parent, double unexpectedValue, double precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<float>> NotBeApproximately(this AwesomeAssertions.Numeric.NumericAssertions<float> parent, float unexpectedValue, float precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<byte>> NotBeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<byte> parent, byte distantValue, byte delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<int>> NotBeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<int> parent, int distantValue, uint delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<long>> NotBeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<long> parent, long distantValue, ulong delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<sbyte>> NotBeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<sbyte> parent, sbyte distantValue, byte delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<short>> NotBeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<short> parent, short distantValue, ushort delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<uint>> NotBeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<uint> parent, uint distantValue, uint delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<ulong>> NotBeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<ulong> parent, ulong distantValue, ulong delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<ushort>> NotBeCloseTo(this AwesomeAssertions.Numeric.NumericAssertions<ushort> parent, ushort distantValue, ushort delta, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<double>> NotBeNaN(this AwesomeAssertions.Numeric.NullableNumericAssertions<double> parent, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NullableNumericAssertions<float>> NotBeNaN(this AwesomeAssertions.Numeric.NullableNumericAssertions<float> parent, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<double>> NotBeNaN(this AwesomeAssertions.Numeric.NumericAssertions<double> parent, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Numeric.NumericAssertions<float>> NotBeNaN(this AwesomeAssertions.Numeric.NumericAssertions<float> parent, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public static class ObjectAssertionsExtensions
    {
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Primitives.ObjectAssertions> BeDataContractSerializable(this AwesomeAssertions.Primitives.ObjectAssertions assertions, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Primitives.ObjectAssertions> BeDataContractSerializable<T>(this AwesomeAssertions.Primitives.ObjectAssertions assertions, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<T>, AwesomeAssertions.Equivalency.EquivalencyOptions<T>> options, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public static AwesomeAssertions.AndConstraint<AwesomeAssertions.Primitives.ObjectAssertions> BeXmlSerializable(this AwesomeAssertions.Primitives.ObjectAssertions assertions, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public abstract class OccurrenceConstraint
    {
        protected OccurrenceConstraint(int expectedCount) { }
    }
    public static class TypeEnumerableExtensions
    {
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreClasses(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreDecoratedWith<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)
            where TAttribute : System.Attribute { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreDecoratedWithOrInherit<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)
            where TAttribute : System.Attribute { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreInNamespace(this System.Collections.Generic.IEnumerable<System.Type> types, string @namespace) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotClasses(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotDecoratedWith<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)
            where TAttribute : System.Attribute { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotDecoratedWithOrInherit<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)
            where TAttribute : System.Attribute { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotStatic(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreStatic(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatAreUnderNamespace(this System.Collections.Generic.IEnumerable<System.Type> types, string @namespace) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatDeriveFrom<T>(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatImplement<T>(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> ThatSatisfy(this System.Collections.Generic.IEnumerable<System.Type> types, System.Func<System.Type, bool> predicate) { }
        public static System.Collections.Generic.IEnumerable<System.Type> UnwrapEnumerableTypes(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static System.Collections.Generic.IEnumerable<System.Type> UnwrapTaskTypes(this System.Collections.Generic.IEnumerable<System.Type> types) { }
    }
    public static class TypeExtensions
    {
        public static AwesomeAssertions.Types.MethodInfoSelector Methods(this AwesomeAssertions.Types.TypeSelector typeSelector) { }
        public static AwesomeAssertions.Types.MethodInfoSelector Methods(this System.Type type) { }
        public static AwesomeAssertions.Types.PropertyInfoSelector Properties(this AwesomeAssertions.Types.TypeSelector typeSelector) { }
        public static AwesomeAssertions.Types.PropertyInfoSelector Properties(this System.Type type) { }
        public static AwesomeAssertions.Types.TypeSelector Types(this System.Collections.Generic.IEnumerable<System.Type> types) { }
        public static AwesomeAssertions.Types.TypeSelector Types(this System.Reflection.Assembly assembly) { }
        public static AwesomeAssertions.Types.TypeSelector Types(this System.Type type) { }
    }
    public static class XmlAssertionExtensions
    {
        public static AwesomeAssertions.Xml.XmlElementAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.XmlElement actualValue) { }
        public static AwesomeAssertions.Xml.XmlNodeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.XmlNode actualValue) { }
    }
}
namespace AwesomeAssertions.Collections
{
    public class GenericCollectionAssertions<T> : AwesomeAssertions.Collections.GenericCollectionAssertions<System.Collections.Generic.IEnumerable<T>, T, AwesomeAssertions.Collections.GenericCollectionAssertions<T>>
    {
        public GenericCollectionAssertions(System.Collections.Generic.IEnumerable<T> actualValue, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class GenericCollectionAssertions<TCollection, T> : AwesomeAssertions.Collections.GenericCollectionAssertions<TCollection, T, AwesomeAssertions.Collections.GenericCollectionAssertions<TCollection, T>>
        where TCollection : System.Collections.Generic.IEnumerable<T>
    {
        public GenericCollectionAssertions(TCollection actualValue, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class GenericCollectionAssertions<TCollection, T, TAssertions> : AwesomeAssertions.Primitives.ReferenceTypeAssertions<TCollection, TAssertions>
        where TCollection : System.Collections.Generic.IEnumerable<T>
        where TAssertions : AwesomeAssertions.Collections.GenericCollectionAssertions<TCollection, T, TAssertions>
    {
        public GenericCollectionAssertions(TCollection actualValue, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> AllBeAssignableTo(System.Type expectedType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TExpectation>> AllBeAssignableTo<TExpectation>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> AllBeEquivalentTo<TExpectation>(TExpectation expectation, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> AllBeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>, AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> AllBeOfType(System.Type expectedType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TExpectation>> AllBeOfType<TExpectation>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> AllSatisfy(System.Action<T> expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        protected void AssertCollectionEndsWith<TActual, TExpectation>(System.Collections.Generic.IEnumerable<TActual> actual, System.Collections.Generic.ICollection<TExpectation> expected, System.Func<TActual, TExpectation, bool> equalityComparison, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        protected void AssertCollectionStartsWith<TActual, TExpectation>(System.Collections.Generic.IEnumerable<TActual> actualItems, System.Collections.Generic.ICollection<TExpectation> expected, System.Func<TActual, TExpectation, bool> equalityComparison, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        protected void AssertSubjectEquality<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEmpty([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>, AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(System.Collections.Generic.IComparer<T> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(System.Func<T, T, int> comparison, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(System.Collections.Generic.IComparer<T> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(System.Func<T, T, int> comparison, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNullOrEmpty([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeSubsetOf(System.Collections.Generic.IEnumerable<T> expectedSuperset, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.IEnumerable<T> expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, T> Contain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, T> Contain(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<T>> Contain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, AwesomeAssertions.OccurrenceConstraint occurrenceConstraint, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<T>> Contain(T expected, AwesomeAssertions.OccurrenceConstraint occurrenceConstraint, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, T> ContainEquivalentOf<TExpectation>(TExpectation expectation, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, T> ContainEquivalentOf<TExpectation>(TExpectation expectation, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>, AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainInConsecutiveOrder(params T[] expected) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainInConsecutiveOrder(System.Collections.Generic.IEnumerable<T> expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainInOrder(params T[] expected) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainInOrder(System.Collections.Generic.IEnumerable<T> expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainItemsAssignableTo<TExpectation>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, T> ContainSingle(string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, T> ContainSingle(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> EndWith(System.Collections.Generic.IEnumerable<T> expectation, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> EndWith(T element, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> EndWith<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Equal(params T[] elements) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Equal(System.Collections.Generic.IEnumerable<T> expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Equal<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveCount(System.Linq.Expressions.Expression<System.Func<int, bool>> countPredicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveCount(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveCountGreaterThan(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveCountGreaterThanOrEqualTo(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveCountLessThan(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveCountLessThanOrEqualTo(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, T> HaveElementAt(int index, T element, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveElementPreceding(T successor, T expectation, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveElementSucceeding(T predecessor, T expectation, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveSameCount<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> otherCollection, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> IntersectWith(System.Collections.Generic.IEnumerable<T> otherCollection, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeEmpty(string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> unexpected, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>, AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder(string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder(System.Collections.Generic.IComparer<T> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder(System.Func<T, T, int> comparison, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder(string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder(System.Collections.Generic.IComparer<T> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder(System.Func<T, T, int> comparison, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeNullOrEmpty(string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeSubsetOf(System.Collections.Generic.IEnumerable<T> unexpectedSuperset, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.IEnumerable<T> unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContain(T unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainEquivalentOf<TExpectation>(TExpectation unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainEquivalentOf<TExpectation>(TExpectation unexpected, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>, AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainInConsecutiveOrder(params T[] unexpected) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainInConsecutiveOrder(System.Collections.Generic.IEnumerable<T> unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainInOrder(params T[] unexpected) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainInOrder(System.Collections.Generic.IEnumerable<T> unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainItemsAssignableTo(System.Type type, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainItemsAssignableTo<TExpectation>(string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainNulls(string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainNulls<TKey>(System.Linq.Expressions.Expression<System.Func<T, TKey>> predicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TKey :  class { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotEqual(System.Collections.Generic.IEnumerable<T> unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveCount(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveSameCount<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> otherCollection, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotIntersectWith(System.Collections.Generic.IEnumerable<T> otherCollection, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> OnlyContain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> OnlyHaveUniqueItems(string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> OnlyHaveUniqueItems<TKey>(System.Linq.Expressions.Expression<System.Func<T, TKey>> predicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Satisfy(params System.Linq.Expressions.Expression<System.Func<T, bool>>[] predicates) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Satisfy(System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression<System.Func<T, bool>>> predicates, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> SatisfyRespectively(params System.Action<T>[] elementInspectors) { }
        public AwesomeAssertions.AndConstraint<TAssertions> SatisfyRespectively(System.Collections.Generic.IEnumerable<System.Action<T>> expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> StartWith(System.Collections.Generic.IEnumerable<T> expectation, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> StartWith(T element, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> StartWith<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        protected static System.Collections.Generic.IEnumerable<TExpectation> RepeatAsManyAs<TExpectation>(TExpectation value, System.Collections.Generic.IEnumerable<T> enumerable) { }
    }
    public class GenericDictionaryAssertions<TCollection, TKey, TValue> : AwesomeAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, AwesomeAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue>>
        where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>
    {
        public GenericDictionaryAssertions(TCollection keyValuePairs, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions> : AwesomeAssertions.Collections.GenericCollectionAssertions<TCollection, System.Collections.Generic.KeyValuePair<TKey, TValue>, TAssertions>
        where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>
        where TAssertions : AwesomeAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions>
    {
        public GenericDictionaryAssertions(TCollection keyValuePairs, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>, AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Contain(params System.Collections.Generic.KeyValuePair<TKey, TValue>[] expected) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.KeyValuePair<TKey, TValue> expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Contain(TKey key, TValue value, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.Collections.WhoseValueConstraint<TCollection, TKey, TValue, TAssertions> ContainKey(TKey expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainKeys(params TKey[] expected) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainKeys(System.Collections.Generic.IEnumerable<TKey> expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, TValue> ContainValue(TValue expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TValue>> ContainValues(params TValue[] expected) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TValue>> ContainValues(System.Collections.Generic.IEnumerable<TValue> expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Equal<T>(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where T : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContain(params System.Collections.Generic.KeyValuePair<TKey, TValue>[] items) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> items, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.KeyValuePair<TKey, TValue> item, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContain(TKey key, TValue value, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainKey(TKey unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainKeys(params TKey[] unexpected) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainKeys(System.Collections.Generic.IEnumerable<TKey> unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainValue(TValue unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainValues(params TValue[] unexpected) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainValues(System.Collections.Generic.IEnumerable<TValue> unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotEqual<T>(T unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where T : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }
    }
    public class StringCollectionAssertions : AwesomeAssertions.Collections.StringCollectionAssertions<System.Collections.Generic.IEnumerable<string>>
    {
        public StringCollectionAssertions(System.Collections.Generic.IEnumerable<string> actualValue, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class StringCollectionAssertions<TCollection> : AwesomeAssertions.Collections.StringCollectionAssertions<TCollection, AwesomeAssertions.Collections.StringCollectionAssertions<TCollection>>
        where TCollection : System.Collections.Generic.IEnumerable<string>
    {
        public StringCollectionAssertions(TCollection actualValue, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class StringCollectionAssertions<TCollection, TAssertions> : AwesomeAssertions.Collections.GenericCollectionAssertions<TCollection, string, TAssertions>
        where TCollection : System.Collections.Generic.IEnumerable<string>
        where TAssertions : AwesomeAssertions.Collections.StringCollectionAssertions<TCollection, TAssertions>
    {
        public StringCollectionAssertions(TCollection actualValue, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.AndConstraint<TAssertions> AllBe(string expectation, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> AllBe(string expectation, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<string>, AwesomeAssertions.Equivalency.EquivalencyOptions<string>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo(params string[] expectation) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Collections.Generic.IEnumerable<string> expectation, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Collections.Generic.IEnumerable<string> expectation, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<string>, AwesomeAssertions.Equivalency.EquivalencyOptions<string>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, string> ContainMatch(string wildcardPattern, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Equal(System.Collections.Generic.IEnumerable<string> expected) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Equal(params string[] expected) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainMatch(string wildcardPattern, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class SubsequentOrderingAssertions<T> : AwesomeAssertions.Collections.GenericCollectionAssertions<System.Collections.Generic.IEnumerable<T>, T>
    {
        public SubsequentOrderingAssertions(System.Collections.Generic.IEnumerable<T> actualValue, System.Linq.IOrderedEnumerable<T> previousOrderedEnumerable, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class WhoseValueConstraint<TCollection, TKey, TValue, TAssertions> : AwesomeAssertions.AndConstraint<TAssertions>
        where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>
        where TAssertions : AwesomeAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions>
    {
        public WhoseValueConstraint(TAssertions parentConstraint, TValue value) { }
        public TValue WhoseValue { get; }
    }
}
namespace AwesomeAssertions.Common
{
    public enum CSharpAccessModifier
    {
        Public = 0,
        Private = 1,
        Protected = 2,
        Internal = 3,
        ProtectedInternal = 4,
        InvalidForCSharp = 5,
        PrivateProtected = 6,
    }
    public static class DateTimeExtensions
    {
        public static System.DateTimeOffset ToDateTimeOffset(this System.DateTime dateTime) { }
        public static System.DateTimeOffset ToDateTimeOffset(this System.DateTime dateTime, System.TimeSpan offset) { }
    }
    public interface IClock
    {
        void Delay(System.TimeSpan timeToDelay);
        System.Threading.Tasks.Task DelayAsync(System.TimeSpan delay, System.Threading.CancellationToken cancellationToken);
        AwesomeAssertions.Common.ITimer StartTimer();
    }
    public interface ITimer : System.IDisposable
    {
        System.TimeSpan Elapsed { get; }
    }
    public delegate AwesomeAssertions.Common.ITimer StartTimer();
    public enum ValueFormatterDetectionMode
    {
        Disabled = 0,
        Specific = 1,
        Scan = 2,
    }
}
namespace AwesomeAssertions.Configuration
{
    public class GlobalConfiguration
    {
        public GlobalConfiguration() { }
        public AwesomeAssertions.Configuration.GlobalEquivalencyOptions Equivalency { get; set; }
        public AwesomeAssertions.Configuration.GlobalFormattingOptions Formatting { get; set; }
        public AwesomeAssertions.Configuration.TestFramework? TestFramework { get; set; }
    }
    public class GlobalEquivalencyOptions
    {
        public GlobalEquivalencyOptions() { }
        public AwesomeAssertions.Equivalency.EquivalencyPlan Plan { get; }
        public AwesomeAssertions.Equivalency.EquivalencyOptions<T> CloneDefaults<T>() { }
        public void Modify(System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions, AwesomeAssertions.Equivalency.EquivalencyOptions> configureOptions) { }
    }
    public class GlobalFormattingOptions : AwesomeAssertions.Formatting.FormattingOptions
    {
        public GlobalFormattingOptions() { }
        public string ValueFormatterAssembly { get; set; }
        public AwesomeAssertions.Common.ValueFormatterDetectionMode ValueFormatterDetectionMode { get; set; }
    }
    public enum TestFramework
    {
        XUnit2 = 0,
        XUnit3 = 1,
        TUnit = 2,
        MsTest = 3,
        NUnit = 4,
        MSpec = 5,
    }
}
namespace AwesomeAssertions.Equivalency
{
    public class Comparands
    {
        public Comparands() { }
        public Comparands(object subject, object expectation, System.Type compileTimeType) { }
        public System.Type CompileTimeType { get; set; }
        public object Expectation { get; set; }
        public System.Type RuntimeType { get; }
        public object Subject { get; set; }
        public System.Type GetExpectedType(AwesomeAssertions.Equivalency.IEquivalencyOptions options) { }
        public override string ToString() { }
    }
    public class ConversionSelector
    {
        public ConversionSelector() { }
        public AwesomeAssertions.Equivalency.ConversionSelector Clone() { }
        public void Exclude(System.Linq.Expressions.Expression<System.Func<AwesomeAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
        public void Include(System.Linq.Expressions.Expression<System.Func<AwesomeAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
        public void IncludeAll() { }
        public bool RequiresConversion(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.INode currentNode) { }
        public override string ToString() { }
    }
    public enum CyclicReferenceHandling
    {
        Ignore = 0,
        ThrowException = 1,
    }
    public enum EnumEquivalencyHandling
    {
        ByValue = 0,
        ByName = 1,
    }
    public enum EqualityStrategy
    {
        Equals = 0,
        Members = 1,
        ForceEquals = 2,
        ForceMembers = 3,
    }
    public class EquivalencyOptions : AwesomeAssertions.Equivalency.SelfReferenceEquivalencyOptions<AwesomeAssertions.Equivalency.EquivalencyOptions>
    {
        public EquivalencyOptions() { }
    }
    public class EquivalencyOptions<TExpectation> : AwesomeAssertions.Equivalency.SelfReferenceEquivalencyOptions<AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>>
    {
        public EquivalencyOptions() { }
        public EquivalencyOptions(AwesomeAssertions.Equivalency.IEquivalencyOptions defaults) { }
        public AwesomeAssertions.Equivalency.EquivalencyOptions<System.Collections.Generic.IEnumerable<TExpectation>> AsCollection() { }
        public AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation> Excluding(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }
        public AwesomeAssertions.Equivalency.NestedExclusionOptionBuilder<TExpectation, TNext> For<TNext>(System.Linq.Expressions.Expression<System.Func<TExpectation, System.Collections.Generic.IEnumerable<TNext>>> expression) { }
        public AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation> Including(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }
        public AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping(string expectationMemberPath, string subjectMemberPath) { }
        public AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TSubject>(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expectationMemberPath, System.Linq.Expressions.Expression<System.Func<TSubject, object>> subjectMemberPath) { }
        public AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(System.Linq.Expressions.Expression<System.Func<TNestedExpectation, object>> expectationMember, System.Linq.Expressions.Expression<System.Func<TNestedSubject, object>> subjectMember) { }
        public AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(string expectationMemberName, string subjectMemberName) { }
        public AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation> WithStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }
        public AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation> WithoutStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }
    }
    public class EquivalencyPlan : System.Collections.Generic.IEnumerable<AwesomeAssertions.Equivalency.IEquivalencyStep>, System.Collections.IEnumerable
    {
        public EquivalencyPlan() { }
        public void Add<TStep>()
            where TStep : AwesomeAssertions.Equivalency.IEquivalencyStep, new () { }
        public void AddAfter<TPredecessor, TStep>()
            where TStep : AwesomeAssertions.Equivalency.IEquivalencyStep, new () { }
        public void Clear() { }
        public System.Collections.Generic.IEnumerator<AwesomeAssertions.Equivalency.IEquivalencyStep> GetEnumerator() { }
        public void Insert<TStep>()
            where TStep : AwesomeAssertions.Equivalency.IEquivalencyStep, new () { }
        public void InsertBefore<TSuccessor, TStep>()
            where TStep : AwesomeAssertions.Equivalency.IEquivalencyStep, new () { }
        public void Remove<TStep>()
            where TStep : AwesomeAssertions.Equivalency.IEquivalencyStep { }
        public void Reset() { }
    }
    public enum EquivalencyResult
    {
        ContinueWithNext = 0,
        EquivalencyProven = 1,
    }
    public abstract class EquivalencyStep<T> : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        protected EquivalencyStep() { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
        protected abstract AwesomeAssertions.Equivalency.EquivalencyResult OnHandle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator);
    }
    public class EquivalencyValidationContext : AwesomeAssertions.Equivalency.IEquivalencyValidationContext
    {
        public EquivalencyValidationContext(AwesomeAssertions.Equivalency.INode root, AwesomeAssertions.Equivalency.IEquivalencyOptions options) { }
        public AwesomeAssertions.Equivalency.INode CurrentNode { get; }
        public AwesomeAssertions.Equivalency.IEquivalencyOptions Options { get; }
        public AwesomeAssertions.Execution.Reason Reason { get; set; }
        public AwesomeAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; set; }
        public AwesomeAssertions.Equivalency.Tracing.Tracer Tracer { get; }
        public AwesomeAssertions.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index) { }
        public AwesomeAssertions.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key) { }
        public AwesomeAssertions.Equivalency.IEquivalencyValidationContext AsNestedMember(AwesomeAssertions.Equivalency.IMember expectationMember) { }
        public AwesomeAssertions.Equivalency.IEquivalencyValidationContext Clone() { }
        public bool IsCyclicReference(object expectation) { }
        public override string ToString() { }
    }
    public delegate string GetSubjectId();
    public interface IAssertionContext<TSubject>
    {
        string Because { get; set; }
        object[] BecauseArgs { get; set; }
        TSubject Expectation { get; }
        AwesomeAssertions.Equivalency.INode SelectedNode { get; }
        TSubject Subject { get; }
    }
    public interface IEquivalencyOptions
    {
        bool AllowInfiniteRecursion { get; }
        bool? CompareRecordsByValue { get; }
        AwesomeAssertions.Equivalency.ConversionSelector ConversionSelector { get; }
        AwesomeAssertions.Equivalency.CyclicReferenceHandling CyclicReferenceHandling { get; }
        AwesomeAssertions.Equivalency.EnumEquivalencyHandling EnumEquivalencyHandling { get; }
        bool ExcludeNonBrowsableOnExpectation { get; }
        bool IgnoreCase { get; }
        bool IgnoreLeadingWhitespace { get; }
        bool IgnoreNewlineStyle { get; }
        bool IgnoreNonBrowsableOnSubject { get; }
        bool IgnoreTrailingWhitespace { get; }
        AwesomeAssertions.Equivalency.MemberVisibility IncludedFields { get; }
        AwesomeAssertions.Equivalency.MemberVisibility IncludedProperties { get; }
        bool IsRecursive { get; }
        System.Collections.Generic.IEnumerable<AwesomeAssertions.Equivalency.IMemberMatchingRule> MatchingRules { get; }
        AwesomeAssertions.Equivalency.OrderingRuleCollection OrderingRules { get; }
        System.Collections.Generic.IEnumerable<AwesomeAssertions.Equivalency.IMemberSelectionRule> SelectionRules { get; }
        AwesomeAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; }
        bool UseRuntimeTyping { get; }
        System.Collections.Generic.IEnumerable<AwesomeAssertions.Equivalency.IEquivalencyStep> UserEquivalencySteps { get; }
        AwesomeAssertions.Equivalency.EqualityStrategy GetEqualityStrategy(System.Type type);
    }
    public interface IEquivalencyStep
    {
        AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes);
    }
    public interface IEquivalencyValidationContext
    {
        AwesomeAssertions.Equivalency.INode CurrentNode { get; }
        AwesomeAssertions.Equivalency.IEquivalencyOptions Options { get; }
        AwesomeAssertions.Execution.Reason Reason { get; }
        AwesomeAssertions.Equivalency.Tracing.Tracer Tracer { get; }
        AwesomeAssertions.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index);
        AwesomeAssertions.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key);
        AwesomeAssertions.Equivalency.IEquivalencyValidationContext AsNestedMember(AwesomeAssertions.Equivalency.IMember expectationMember);
        AwesomeAssertions.Equivalency.IEquivalencyValidationContext Clone();
        bool IsCyclicReference(object expectation);
    }
    public interface IMember : AwesomeAssertions.Equivalency.INode
    {
        System.Type DeclaringType { get; }
        AwesomeAssertions.Common.CSharpAccessModifier GetterAccessibility { get; }
        bool IsBrowsable { get; }
        System.Type ReflectedType { get; }
        AwesomeAssertions.Common.CSharpAccessModifier SetterAccessibility { get; }
        object GetValue(object obj);
    }
    public interface IMemberInfo
    {
        System.Type DeclaringType { get; }
        AwesomeAssertions.Common.CSharpAccessModifier GetterAccessibility { get; }
        string Name { get; }
        string Path { get; set; }
        AwesomeAssertions.Common.CSharpAccessModifier SetterAccessibility { get; }
        System.Type Type { get; }
    }
    public interface IMemberMatchingRule
    {
        AwesomeAssertions.Equivalency.IMember Match(AwesomeAssertions.Equivalency.IMember expectedMember, object subject, AwesomeAssertions.Equivalency.INode parent, AwesomeAssertions.Equivalency.IEquivalencyOptions options, AwesomeAssertions.Execution.AssertionChain assertionChain);
    }
    public interface IMemberSelectionRule
    {
        bool IncludesMembers { get; }
        System.Collections.Generic.IEnumerable<AwesomeAssertions.Equivalency.IMember> SelectMembers(AwesomeAssertions.Equivalency.INode currentNode, System.Collections.Generic.IEnumerable<AwesomeAssertions.Equivalency.IMember> selectedMembers, AwesomeAssertions.Equivalency.MemberSelectionContext context);
    }
    public interface INode
    {
        int Depth { get; }
        AwesomeAssertions.Equivalency.Pathway Expectation { get; }
        AwesomeAssertions.Equivalency.GetSubjectId GetSubjectId { get; }
        bool IsRoot { get; }
        System.Type ParentType { get; }
        bool RootIsCollection { get; }
        AwesomeAssertions.Equivalency.Pathway Subject { get; }
        System.Type Type { get; }
        void AdjustForRemappedSubject(AwesomeAssertions.Equivalency.IMember subjectMember);
    }
    public interface IObjectInfo
    {
        System.Type CompileTimeType { get; }
        System.Type ParentType { get; }
        string Path { get; set; }
        System.Type RuntimeType { get; }
        [System.Obsolete("Use CompileTimeType or RuntimeType instead")]
        System.Type Type { get; }
    }
    public interface IOrderingRule
    {
        AwesomeAssertions.Equivalency.OrderStrictness Evaluate(AwesomeAssertions.Equivalency.IObjectInfo objectInfo);
    }
    public interface IValidateChildNodeEquivalency
    {
        void AssertEquivalencyOf(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context);
    }
    public static class MemberFactory
    {
        public static AwesomeAssertions.Equivalency.IMember Create(System.Reflection.MemberInfo memberInfo, AwesomeAssertions.Equivalency.INode parent) { }
    }
    public class MemberSelectionContext
    {
        public MemberSelectionContext(System.Type compileTimeType, System.Type runtimeType, AwesomeAssertions.Equivalency.IEquivalencyOptions options) { }
        public AwesomeAssertions.Equivalency.MemberVisibility IncludedFields { get; }
        public AwesomeAssertions.Equivalency.MemberVisibility IncludedProperties { get; }
        public System.Type Type { get; }
    }
    [System.Flags]
    public enum MemberVisibility
    {
        None = 0,
        Internal = 1,
        Public = 2,
        ExplicitlyImplemented = 4,
        DefaultInterfaceProperties = 8,
    }
    public class NestedExclusionOptionBuilder<TExpectation, TCurrent>
    {
        public AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation> Exclude(System.Linq.Expressions.Expression<System.Func<TCurrent, object>> expression) { }
        public AwesomeAssertions.Equivalency.NestedExclusionOptionBuilder<TExpectation, TNext> For<TNext>(System.Linq.Expressions.Expression<System.Func<TCurrent, System.Collections.Generic.IEnumerable<TNext>>> expression) { }
    }
    public enum OrderStrictness
    {
        Strict = 0,
        NotStrict = 1,
        Irrelevant = 2,
    }
    public class OrderingRuleCollection : System.Collections.Generic.IEnumerable<AwesomeAssertions.Equivalency.IOrderingRule>, System.Collections.IEnumerable
    {
        public OrderingRuleCollection() { }
        public OrderingRuleCollection(System.Collections.Generic.IEnumerable<AwesomeAssertions.Equivalency.IOrderingRule> orderingRules) { }
        public void Add(AwesomeAssertions.Equivalency.IOrderingRule rule) { }
        public System.Collections.Generic.IEnumerator<AwesomeAssertions.Equivalency.IOrderingRule> GetEnumerator() { }
        public bool IsOrderingStrictFor(AwesomeAssertions.Equivalency.IObjectInfo objectInfo) { }
    }
    public class Pathway : System.IEquatable<AwesomeAssertions.Equivalency.Pathway>
    {
        public Pathway(AwesomeAssertions.Equivalency.Pathway parent, string name, AwesomeAssertions.Equivalency.Pathway.GetDescription getDescription) { }
        public Pathway(string path, string name, AwesomeAssertions.Equivalency.Pathway.GetDescription getDescription) { }
        public string Description { get; }
        public string Name { get; }
        public string Path { get; }
        public string PathAndName { get; }
        public override string ToString() { }
        public delegate string GetDescription(string pathAndName);
    }
    public abstract class SelfReferenceEquivalencyOptions<TSelf> : AwesomeAssertions.Equivalency.IEquivalencyOptions
        where TSelf : AwesomeAssertions.Equivalency.SelfReferenceEquivalencyOptions<TSelf>
    {
        protected SelfReferenceEquivalencyOptions(AwesomeAssertions.Equivalency.IEquivalencyOptions defaults) { }
        public bool? CompareRecordsByValue { get; }
        public AwesomeAssertions.Equivalency.ConversionSelector ConversionSelector { get; }
        public bool IgnoreCase { get; }
        public bool IgnoreLeadingWhitespace { get; }
        public bool IgnoreNewlineStyle { get; }
        public bool IgnoreTrailingWhitespace { get; }
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        protected AwesomeAssertions.Equivalency.OrderingRuleCollection OrderingRules { get; }
        public AwesomeAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; }
        protected TSelf AddMatchingRule(AwesomeAssertions.Equivalency.IMemberMatchingRule matchingRule) { }
        protected TSelf AddSelectionRule(AwesomeAssertions.Equivalency.IMemberSelectionRule selectionRule) { }
        public TSelf AllowingInfiniteRecursion() { }
        public TSelf ComparingByMembers(System.Type type) { }
        public TSelf ComparingByMembers<T>() { }
        public TSelf ComparingByValue(System.Type type) { }
        public TSelf ComparingByValue<T>() { }
        public TSelf ComparingEnumsByName() { }
        public TSelf ComparingEnumsByValue() { }
        public TSelf ComparingRecordsByMembers() { }
        public TSelf ComparingRecordsByValue() { }
        public TSelf Excluding(System.Linq.Expressions.Expression<System.Func<AwesomeAssertions.Equivalency.IMemberInfo, bool>> predicate) { }
        public TSelf ExcludingExplicitlyImplementedProperties() { }
        public TSelf ExcludingFields() { }
        public TSelf ExcludingMissingMembers() { }
        public TSelf ExcludingNonBrowsableMembers() { }
        public TSelf ExcludingProperties() { }
        public TSelf IgnoringCase() { }
        public TSelf IgnoringCyclicReferences() { }
        public TSelf IgnoringLeadingWhitespace() { }
        public TSelf IgnoringNewlineStyle() { }
        public TSelf IgnoringNonBrowsableMembersOnSubject() { }
        public TSelf IgnoringTrailingWhitespace() { }
        public TSelf Including(System.Linq.Expressions.Expression<System.Func<AwesomeAssertions.Equivalency.IMemberInfo, bool>> predicate) { }
        public TSelf IncludingAllDeclaredProperties() { }
        public TSelf IncludingAllRuntimeProperties() { }
        public TSelf IncludingFields() { }
        public TSelf IncludingInternalFields() { }
        public TSelf IncludingInternalProperties() { }
        public TSelf IncludingNestedObjects() { }
        public TSelf IncludingProperties() { }
        public TSelf PreferringDeclaredMemberTypes() { }
        public TSelf PreferringRuntimeMemberTypes() { }
        public TSelf ThrowingOnMissingMembers() { }
        public override string ToString() { }
        public TSelf Using(AwesomeAssertions.Equivalency.IEquivalencyStep equivalencyStep) { }
        public TSelf Using(AwesomeAssertions.Equivalency.IMemberMatchingRule matchingRule) { }
        public TSelf Using(AwesomeAssertions.Equivalency.IMemberSelectionRule selectionRule) { }
        public TSelf Using(AwesomeAssertions.Equivalency.IOrderingRule orderingRule) { }
        public TSelf Using(System.Collections.Generic.IEqualityComparer<string> comparer) { }
        public AwesomeAssertions.Equivalency.SelfReferenceEquivalencyOptions<TSelf>.Restriction<TProperty> Using<TProperty>(System.Action<AwesomeAssertions.Equivalency.IAssertionContext<TProperty>> action) { }
        public TSelf Using<T>(System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public TSelf Using<T, TEqualityComparer>()
            where TEqualityComparer : System.Collections.Generic.IEqualityComparer<T>, new () { }
        public TSelf WithAutoConversion() { }
        public TSelf WithAutoConversionFor(System.Linq.Expressions.Expression<System.Func<AwesomeAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
        public TSelf WithStrictOrdering() { }
        public TSelf WithStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<AwesomeAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
        public TSelf WithTracing(AwesomeAssertions.Equivalency.Tracing.ITraceWriter writer = null) { }
        public TSelf WithoutAutoConversionFor(System.Linq.Expressions.Expression<System.Func<AwesomeAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
        public TSelf WithoutMatchingRules() { }
        public TSelf WithoutRecursing() { }
        public TSelf WithoutSelectionRules() { }
        public TSelf WithoutStrictOrdering() { }
        public TSelf WithoutStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<AwesomeAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
        public class Restriction<TMember>
        {
            public Restriction(TSelf options, System.Action<AwesomeAssertions.Equivalency.IAssertionContext<TMember>> action) { }
            public TSelf When(System.Linq.Expressions.Expression<System.Func<AwesomeAssertions.Equivalency.IObjectInfo, bool>> predicate) { }
            public TSelf WhenTypeIs<TMemberType>()
                where TMemberType : TMember { }
        }
    }
    public static class SubjectInfoExtensions
    {
        public static bool WhichGetterDoesNotHave(this AwesomeAssertions.Equivalency.IMemberInfo memberInfo, AwesomeAssertions.Common.CSharpAccessModifier accessModifier) { }
        public static bool WhichGetterHas(this AwesomeAssertions.Equivalency.IMemberInfo memberInfo, AwesomeAssertions.Common.CSharpAccessModifier accessModifier) { }
        public static bool WhichSetterDoesNotHave(this AwesomeAssertions.Equivalency.IMemberInfo memberInfo, AwesomeAssertions.Common.CSharpAccessModifier accessModifier) { }
        public static bool WhichSetterHas(this AwesomeAssertions.Equivalency.IMemberInfo memberInfo, AwesomeAssertions.Common.CSharpAccessModifier accessModifier) { }
    }
}
namespace AwesomeAssertions.Equivalency.Steps
{
    public class AssertionRuleEquivalencyStep<TSubject> : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        public AssertionRuleEquivalencyStep(System.Linq.Expressions.Expression<System.Func<AwesomeAssertions.Equivalency.IObjectInfo, bool>> predicate, System.Action<AwesomeAssertions.Equivalency.IAssertionContext<TSubject>> assertionAction) { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
        public override string ToString() { }
    }
    public class AutoConversionStep : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        public AutoConversionStep() { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
        public override string ToString() { }
    }
    public class DictionaryEquivalencyStep : AwesomeAssertions.Equivalency.EquivalencyStep<System.Collections.IDictionary>
    {
        public DictionaryEquivalencyStep() { }
        protected override AwesomeAssertions.Equivalency.EquivalencyResult OnHandle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }
    }
    public class EnumEqualityStep : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        public EnumEqualityStep() { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class EnumerableEquivalencyStep : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        public EnumerableEquivalencyStep() { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class EqualityComparerEquivalencyStep<T> : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        public EqualityComparerEquivalencyStep(System.Collections.Generic.IEqualityComparer<T> comparer) { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
        public override string ToString() { }
    }
    public class GenericDictionaryEquivalencyStep : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        public GenericDictionaryEquivalencyStep() { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class GenericEnumerableEquivalencyStep : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        public GenericEnumerableEquivalencyStep() { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class ReferenceEqualityEquivalencyStep : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        public ReferenceEqualityEquivalencyStep() { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class RunAllUserStepsEquivalencyStep : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        public RunAllUserStepsEquivalencyStep() { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class SimpleEqualityEquivalencyStep : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        public SimpleEqualityEquivalencyStep() { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class StringEqualityEquivalencyStep : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        public StringEqualityEquivalencyStep() { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class StructuralEqualityEquivalencyStep : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        public StructuralEqualityEquivalencyStep() { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class ValueTypeEquivalencyStep : AwesomeAssertions.Equivalency.IEquivalencyStep
    {
        public ValueTypeEquivalencyStep() { }
        public AwesomeAssertions.Equivalency.EquivalencyResult Handle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }
    }
    public class XAttributeEquivalencyStep : AwesomeAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XAttribute>
    {
        public XAttributeEquivalencyStep() { }
        protected override AwesomeAssertions.Equivalency.EquivalencyResult OnHandle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }
    }
    public class XDocumentEquivalencyStep : AwesomeAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XDocument>
    {
        public XDocumentEquivalencyStep() { }
        protected override AwesomeAssertions.Equivalency.EquivalencyResult OnHandle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }
    }
    public class XElementEquivalencyStep : AwesomeAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XElement>
    {
        public XElementEquivalencyStep() { }
        protected override AwesomeAssertions.Equivalency.EquivalencyResult OnHandle(AwesomeAssertions.Equivalency.Comparands comparands, AwesomeAssertions.Equivalency.IEquivalencyValidationContext context, AwesomeAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }
    }
}
namespace AwesomeAssertions.Equivalency.Tracing
{
    public delegate string GetTraceMessage(AwesomeAssertions.Equivalency.INode node);
    public interface ITraceWriter
    {
        System.IDisposable AddBlock(string trace);
        void AddSingle(string trace);
        string ToString();
    }
    public class StringBuilderTraceWriter : AwesomeAssertions.Equivalency.Tracing.ITraceWriter
    {
        public StringBuilderTraceWriter() { }
        public System.IDisposable AddBlock(string trace) { }
        public void AddSingle(string trace) { }
        public override string ToString() { }
    }
    public class Tracer
    {
        public override string ToString() { }
        public System.IDisposable WriteBlock(AwesomeAssertions.Equivalency.Tracing.GetTraceMessage getTraceMessage) { }
        public void WriteLine(AwesomeAssertions.Equivalency.Tracing.GetTraceMessage getTraceMessage) { }
    }
}
namespace AwesomeAssertions.Events
{
    public class EventAssertions<T> : AwesomeAssertions.Primitives.ReferenceTypeAssertions<T, AwesomeAssertions.Events.EventAssertions<T>>
    {
        protected EventAssertions(AwesomeAssertions.Events.IMonitor<T> monitor, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.Events.IMonitor<T> Monitor { get; }
        public void NotRaise(string eventName, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public void NotRaisePropertyChangeFor(System.Linq.Expressions.Expression<System.Func<T, object>> propertyExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.Events.IEventRecording Raise(string eventName, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.Events.IEventRecording RaisePropertyChangeFor(System.Linq.Expressions.Expression<System.Func<T, object>> propertyExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class EventMetadata
    {
        public EventMetadata(string eventName, System.Type handlerType) { }
        public string EventName { get; }
        public System.Type HandlerType { get; }
    }
    public class EventMonitorOptions
    {
        public EventMonitorOptions() { }
        public AwesomeAssertions.Events.EventMonitorOptions IgnoringEventAccessorExceptions() { }
        public AwesomeAssertions.Events.EventMonitorOptions RecordingEventsWithBrokenAccessor() { }
    }
    public interface IEventRecording : System.Collections.Generic.IEnumerable<AwesomeAssertions.Events.OccurredEvent>, System.Collections.IEnumerable
    {
        System.Type EventHandlerType { get; }
        string EventName { get; }
        object EventObject { get; }
    }
    public interface IMonitor<T> : System.IDisposable
    {
        AwesomeAssertions.Events.EventMetadata[] MonitoredEvents { get; }
        AwesomeAssertions.Events.OccurredEvent[] OccurredEvents { get; }
        T Subject { get; }
        void Clear();
        AwesomeAssertions.Events.IEventRecording GetRecordingFor(string eventName);
        AwesomeAssertions.Events.EventAssertions<T> Should();
    }
    public class OccurredEvent
    {
        public OccurredEvent() { }
        public string EventName { get; set; }
        public object[] Parameters { get; set; }
        public int Sequence { get; set; }
        public System.DateTime TimestampUtc { get; set; }
    }
}
namespace AwesomeAssertions.Execution
{
    public sealed class AssertionChain
    {
        public string CallerIdentifier { get; }
        public bool HasOverriddenCallerIdentifier { get; }
        public bool Succeeded { get; }
        public AwesomeAssertions.Execution.AssertionChain UsingLineBreaks { get; }
        public void AddReportable(string key, System.Func<string> getValue) { }
        public void AddReportable(string key, string value) { }
        public AwesomeAssertions.Execution.AssertionChain BecauseOf(AwesomeAssertions.Execution.Reason reason) { }
        public AwesomeAssertions.Execution.AssertionChain BecauseOf(string because, params object[] becauseArgs) { }
        public AwesomeAssertions.Execution.Continuation FailWith(System.Func<AwesomeAssertions.Execution.FailReason> getFailureReason) { }
        public AwesomeAssertions.Execution.Continuation FailWith(string message) { }
        public AwesomeAssertions.Execution.Continuation FailWith(string message, params System.Func<object>[] argProviders) { }
        public AwesomeAssertions.Execution.Continuation FailWith(string message, params object[] args) { }
        public AwesomeAssertions.Execution.AssertionChain ForCondition(bool condition) { }
        public AwesomeAssertions.Execution.AssertionChain ForConstraint(AwesomeAssertions.OccurrenceConstraint constraint, int actualOccurrences) { }
        public AwesomeAssertions.Execution.GivenSelector<T> Given<T>(System.Func<T> selector) { }
        public void OverrideCallerIdentifier(System.Func<string> getCallerIdentifier) { }
        public void ReuseOnce() { }
        public AwesomeAssertions.Execution.AssertionChain WithCallerPostfix(string postfix) { }
        public AwesomeAssertions.Execution.AssertionChain WithDefaultIdentifier(string identifier) { }
        public AwesomeAssertions.Execution.Continuation WithExpectation(string message, System.Action<AwesomeAssertions.Execution.AssertionChain> chain) { }
        public AwesomeAssertions.Execution.Continuation WithExpectation(string message, object arg1, System.Action<AwesomeAssertions.Execution.AssertionChain> chain) { }
        public AwesomeAssertions.Execution.Continuation WithExpectation(string message, object arg1, object arg2, System.Action<AwesomeAssertions.Execution.AssertionChain> chain) { }
        public AwesomeAssertions.Execution.AssertionChain WithReportable(string name, System.Func<string> content) { }
        public static AwesomeAssertions.Execution.AssertionChain GetOrCreate() { }
    }
    public class AssertionFailedException : System.Exception
    {
        public AssertionFailedException(string message) { }
    }
    public sealed class AssertionScope : System.IDisposable
    {
        public AssertionScope() { }
        public AssertionScope(AwesomeAssertions.Execution.IAssertionStrategy assertionStrategy) { }
        public AssertionScope(System.Func<string> name) { }
        public AssertionScope(string name) { }
        public AwesomeAssertions.Formatting.FormattingOptions FormattingOptions { get; }
        public System.Func<string> Name { get; }
        public static AwesomeAssertions.Execution.AssertionScope Current { get; }
        public void AddPreFormattedFailure(string formattedFailureMessage) { }
        public void AppendTracing(string tracingBlock) { }
        public string[] Discard() { }
        public void Dispose() { }
        public bool HasFailures() { }
    }
    public class Continuation
    {
        public AwesomeAssertions.Execution.AssertionChain Then { get; }
    }
    public class ContinuationOfGiven<TSubject>
    {
        public bool Succeeded { get; }
        public AwesomeAssertions.Execution.GivenSelector<TSubject> Then { get; }
    }
    public class FailReason
    {
        public FailReason(string message, params object[] args) { }
        public object[] Args { get; }
        public string Message { get; }
    }
    public class GivenSelector<T>
    {
        public bool Succeeded { get; }
        public AwesomeAssertions.Execution.ContinuationOfGiven<T> FailWith(System.Func<T, AwesomeAssertions.Execution.FailReason> failReason) { }
        public AwesomeAssertions.Execution.ContinuationOfGiven<T> FailWith(System.Func<T, string> message) { }
        public AwesomeAssertions.Execution.ContinuationOfGiven<T> FailWith(string message) { }
        public AwesomeAssertions.Execution.ContinuationOfGiven<T> FailWith(string message, params System.Func<T, object>[] args) { }
        public AwesomeAssertions.Execution.ContinuationOfGiven<T> FailWith(string message, params object[] args) { }
        public AwesomeAssertions.Execution.GivenSelector<T> ForCondition(System.Func<T, bool> predicate) { }
        public AwesomeAssertions.Execution.GivenSelector<T> ForConstraint(AwesomeAssertions.OccurrenceConstraint constraint, System.Func<T, int> func) { }
        public AwesomeAssertions.Execution.GivenSelector<TOut> Given<TOut>(System.Func<T, TOut> selector) { }
    }
    public interface IAssertionStrategy
    {
        System.Collections.Generic.IEnumerable<string> FailureMessages { get; }
        System.Collections.Generic.IEnumerable<string> DiscardFailures();
        void HandleFailure(string message);
        void ThrowIfAny(System.Collections.Generic.IDictionary<string, object> context);
    }
    public interface ICloneable2
    {
        object Clone();
    }
    public interface ITestFramework
    {
        bool IsAvailable { get; }
        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        void Throw(string message);
    }
    public class Reason
    {
        public Reason([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string formattedMessage, object[] arguments) { }
        public object[] Arguments { get; set; }
        public string FormattedMessage { get; set; }
    }
}
namespace AwesomeAssertions.Extensibility
{
    [System.AttributeUsage(System.AttributeTargets.Assembly, AllowMultiple=true)]
    public sealed class AssertionEngineInitializerAttribute : System.Attribute
    {
        public AssertionEngineInitializerAttribute(System.Type type, string methodName) { }
    }
}
namespace AwesomeAssertions.Extensions
{
    public static class FluentDateTimeExtensions
    {
        public static System.DateTime AddMicroseconds(this System.DateTime self, long microseconds) { }
        public static System.DateTimeOffset AddMicroseconds(this System.DateTimeOffset self, long microseconds) { }
        public static System.DateTime AddNanoseconds(this System.DateTime self, long nanoseconds) { }
        public static System.DateTimeOffset AddNanoseconds(this System.DateTimeOffset self, long nanoseconds) { }
        public static System.DateTime After(this System.TimeSpan timeDifference, System.DateTime sourceDateTime) { }
        public static System.DateTime April(this int day, int year) { }
        public static System.DateTime AsLocal(this System.DateTime dateTime) { }
        public static System.DateTime AsUtc(this System.DateTime dateTime) { }
        public static System.DateTime At(this System.DateTime date, System.TimeSpan time) { }
        public static System.DateTime At(this System.DateTime date, int hours, int minutes, int seconds = 0, int milliseconds = 0, int microseconds = 0, int nanoseconds = 0) { }
        public static System.DateTimeOffset At(this System.DateTimeOffset date, int hours, int minutes, int seconds = 0, int milliseconds = 0, int microseconds = 0, int nanoseconds = 0) { }
        public static System.DateTime August(this int day, int year) { }
        public static System.DateTime Before(this System.TimeSpan timeDifference, System.DateTime sourceDateTime) { }
        public static System.DateTime December(this int day, int year) { }
        public static System.DateTime February(this int day, int year) { }
        public static System.DateTime January(this int day, int year) { }
        public static System.DateTime July(this int day, int year) { }
        public static System.DateTime June(this int day, int year) { }
        public static System.DateTime March(this int day, int year) { }
        public static System.DateTime May(this int day, int year) { }
        public static int Microsecond(this System.DateTime self) { }
        public static int Microsecond(this System.DateTimeOffset self) { }
        public static int Nanosecond(this System.DateTime self) { }
        public static int Nanosecond(this System.DateTimeOffset self) { }
        public static System.DateTime November(this int day, int year) { }
        public static System.DateTime October(this int day, int year) { }
        public static System.DateTime September(this int day, int year) { }
        public static System.DateTimeOffset WithOffset(this System.DateTime self, System.TimeSpan offset) { }
    }
    public static class FluentTimeSpanExtensions
    {
        public const long TicksPerMicrosecond = 10;
        public const double TicksPerNanosecond = 0.01D;
        public static System.TimeSpan And(this System.TimeSpan sourceTime, System.TimeSpan offset) { }
        public static System.TimeSpan Days(this double days) { }
        public static System.TimeSpan Days(this int days) { }
        public static System.TimeSpan Days(this int days, System.TimeSpan offset) { }
        public static System.TimeSpan Hours(this double hours) { }
        public static System.TimeSpan Hours(this int hours) { }
        public static System.TimeSpan Hours(this int hours, System.TimeSpan offset) { }
        public static int Microseconds(this System.TimeSpan self) { }
        public static System.TimeSpan Microseconds(this int microseconds) { }
        public static System.TimeSpan Microseconds(this long microseconds) { }
        public static System.TimeSpan Milliseconds(this double milliseconds) { }
        public static System.TimeSpan Milliseconds(this int milliseconds) { }
        public static System.TimeSpan Minutes(this double minutes) { }
        public static System.TimeSpan Minutes(this int minutes) { }
        public static System.TimeSpan Minutes(this int minutes, System.TimeSpan offset) { }
        public static int Nanoseconds(this System.TimeSpan self) { }
        public static System.TimeSpan Nanoseconds(this int nanoseconds) { }
        public static System.TimeSpan Nanoseconds(this long nanoseconds) { }
        public static System.TimeSpan Seconds(this double seconds) { }
        public static System.TimeSpan Seconds(this int seconds) { }
        public static System.TimeSpan Seconds(this int seconds, System.TimeSpan offset) { }
        public static System.TimeSpan Ticks(this int ticks) { }
        public static System.TimeSpan Ticks(this long ticks) { }
        public static double TotalMicroseconds(this System.TimeSpan self) { }
        public static double TotalNanoseconds(this System.TimeSpan self) { }
    }
    public static class OccurrenceConstraintExtensions
    {
        public static AwesomeAssertions.OccurrenceConstraint TimesExactly(this int times) { }
        public static AwesomeAssertions.OccurrenceConstraint TimesOrLess(this int times) { }
        public static AwesomeAssertions.OccurrenceConstraint TimesOrMore(this int times) { }
    }
}
namespace AwesomeAssertions.Formatting
{
    public class AggregateExceptionValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public AggregateExceptionValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class AttributeBasedFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public AttributeBasedFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class ByteValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public ByteValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class DateOnlyValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public DateOnlyValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class DateTimeOffsetValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public DateTimeOffsetValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class DecimalValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public DecimalValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class DefaultValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public DefaultValueFormatter() { }
        public virtual bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
        protected virtual System.Reflection.MemberInfo[] GetMembers(System.Type type) { }
        protected virtual string TypeDisplayName(System.Type type) { }
    }
    public class DictionaryValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public DictionaryValueFormatter() { }
        protected virtual int MaxItems { get; }
        public virtual bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class DoubleValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public DoubleValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class EnumValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public EnumValueFormatter() { }
        public virtual bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class EnumerableValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public EnumerableValueFormatter() { }
        protected virtual int MaxItems { get; }
        public virtual bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class ExceptionValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public ExceptionValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class ExpressionValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public ExpressionValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public delegate void FormatChild(string childPath, object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph);
    public class FormattedObjectGraph
    {
        public FormattedObjectGraph(int maxLines) { }
        public int LineCount { get; }
        public static int SpacesPerIndentation { get; }
        public void AddFragment(string fragment) { }
        public void AddFragmentOnNewLine(string fragment) { }
        public void AddLine(string line) { }
        public override string ToString() { }
        public System.IDisposable WithIndentation() { }
    }
    public static class Formatter
    {
        public static System.Collections.Generic.IEnumerable<AwesomeAssertions.Formatting.IValueFormatter> Formatters { get; }
        public static void AddFormatter(AwesomeAssertions.Formatting.IValueFormatter formatter) { }
        public static void RemoveFormatter(AwesomeAssertions.Formatting.IValueFormatter formatter) { }
        public static string ToString(object value, AwesomeAssertions.Formatting.FormattingOptions options = null) { }
    }
    public class FormattingContext
    {
        public FormattingContext() { }
        public bool UseLineBreaks { get; set; }
    }
    public class FormattingOptions
    {
        public FormattingOptions() { }
        public int MaxDepth { get; set; }
        public int MaxLines { get; set; }
        public int StringPrintLength { get; set; }
        public bool UseLineBreaks { get; set; }
        public void AddFormatter(AwesomeAssertions.Formatting.IValueFormatter formatter) { }
        public void RemoveFormatter(AwesomeAssertions.Formatting.IValueFormatter formatter) { }
    }
    public class GuidValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public GuidValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public interface IValueFormatter
    {
        bool CanHandle(object value);
        void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild);
    }
    public class Int16ValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public Int16ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class Int32ValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public Int32ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class Int64ValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public Int64ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class MaxLinesExceededException : System.Exception
    {
        public MaxLinesExceededException() { }
    }
    public class MethodInfoFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public MethodInfoFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class MultidimensionalArrayFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public MultidimensionalArrayFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class NullValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public NullValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class PredicateLambdaExpressionValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public PredicateLambdaExpressionValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class PropertyInfoFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public PropertyInfoFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class SByteValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public SByteValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class SingleValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public SingleValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class StringValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public StringValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class TaskFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public TaskFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class TimeOnlyValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public TimeOnlyValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class TimeSpanValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public TimeSpanValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public sealed class TypeValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public TypeValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class UInt16ValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public UInt16ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class UInt32ValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public UInt32ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class UInt64ValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public UInt64ValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public class ValueFormatterAttribute : System.Attribute
    {
        public ValueFormatterAttribute() { }
    }
    public class XAttributeValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public XAttributeValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class XDocumentValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public XDocumentValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class XElementValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public XElementValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
    public class XmlReaderValueFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public XmlReaderValueFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
}
namespace AwesomeAssertions.Numeric
{
    public class ComparableTypeAssertions<T> : AwesomeAssertions.Numeric.ComparableTypeAssertions<T, AwesomeAssertions.Numeric.ComparableTypeAssertions<T>>
    {
        public ComparableTypeAssertions(System.IComparable<T> value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class ComparableTypeAssertions<T, TAssertions> : AwesomeAssertions.Primitives.ReferenceTypeAssertions<System.IComparable<T>, TAssertions>
        where TAssertions : AwesomeAssertions.Numeric.ComparableTypeAssertions<T, TAssertions>
    {
        public ComparableTypeAssertions(System.IComparable<T> value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>, AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeGreaterThan(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeInRange(T minimumValue, T maximumValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeLessThan(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(params T[] validValues) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<T> validValues, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeRankedEquallyTo(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(T unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeInRange(T minimumValue, T maximumValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeRankedEquallyTo(T unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class NullableNumericAssertions<T> : AwesomeAssertions.Numeric.NullableNumericAssertions<T, AwesomeAssertions.Numeric.NullableNumericAssertions<T>>
        where T :  struct, System.IComparable<T>
    {
        public NullableNumericAssertions(T? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableNumericAssertions<T, TAssertions> : AwesomeAssertions.Numeric.NumericAssertionsBase<T, T?, TAssertions>
        where T :  struct, System.IComparable<T>
        where TAssertions : AwesomeAssertions.Numeric.NullableNumericAssertions<T, TAssertions>
    {
        public NullableNumericAssertions(T? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public override T? Subject { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<T?, bool>> predicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public abstract class NumericAssertionsBase<T, TSubject, TAssertions>
        where T :  struct, System.IComparable<T>
        where TAssertions : AwesomeAssertions.Numeric.NumericAssertionsBase<T, TSubject, TAssertions>
    {
        protected NumericAssertionsBase(AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public abstract TSubject Subject { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(T? expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeGreaterThan(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeInRange(T minimumValue, T maximumValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeLessThan(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNegative([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOfType(System.Type expectedType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(params T[] validValues) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<T> validValues, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BePositive([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(T unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(T? unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeInRange(T minimumValue, T maximumValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeOfType(System.Type unexpectedType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class NumericAssertions<T> : AwesomeAssertions.Numeric.NumericAssertions<T, AwesomeAssertions.Numeric.NumericAssertions<T>>
        where T :  struct, System.IComparable<T>
    {
        public NumericAssertions(T value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NumericAssertions<T, TAssertions> : AwesomeAssertions.Numeric.NumericAssertionsBase<T, T, TAssertions>
        where T :  struct, System.IComparable<T>
        where TAssertions : AwesomeAssertions.Numeric.NumericAssertions<T, TAssertions>
    {
        public NumericAssertions(T value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public override T Subject { get; }
    }
}
namespace AwesomeAssertions.Primitives
{
    public class BooleanAssertions : AwesomeAssertions.Primitives.BooleanAssertions<AwesomeAssertions.Primitives.BooleanAssertions>
    {
        public BooleanAssertions(bool? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class BooleanAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.BooleanAssertions<TAssertions>
    {
        public BooleanAssertions(bool? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public bool? Subject { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(bool expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeFalse([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeTrue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Imply(bool consequent, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(bool unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class DateOnlyAssertions : AwesomeAssertions.Primitives.DateOnlyAssertions<AwesomeAssertions.Primitives.DateOnlyAssertions>
    {
        public DateOnlyAssertions(System.DateOnly? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class DateOnlyAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.DateOnlyAssertions<TAssertions>
    {
        public DateOnlyAssertions(System.DateOnly? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public System.DateOnly? Subject { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(System.DateOnly expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(System.DateOnly? expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeAfter(System.DateOnly expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeBefore(System.DateOnly expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOnOrAfter(System.DateOnly expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOnOrBefore(System.DateOnly expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateOnly[] validValues) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateOnly?[] validValues) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateOnly> validValues, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateOnly?> validValues, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveDay(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveMonth(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveYear(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(System.DateOnly unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(System.DateOnly? unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeAfter(System.DateOnly unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeBefore(System.DateOnly unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeOnOrAfter(System.DateOnly unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeOnOrBefore(System.DateOnly unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveDay(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveMonth(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveYear(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class DateTimeAssertions : AwesomeAssertions.Primitives.DateTimeAssertions<AwesomeAssertions.Primitives.DateTimeAssertions>
    {
        public DateTimeAssertions(System.DateTime? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class DateTimeAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.DateTimeAssertions<TAssertions>
    {
        public DateTimeAssertions(System.DateTime? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public System.DateTime? Subject { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(System.DateTime expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(System.DateTime? expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeAfter(System.DateTime expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeAtLeast(System.TimeSpan timeSpan) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeBefore(System.DateTime expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeCloseTo(System.DateTime nearbyTime, System.TimeSpan precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeExactly(System.TimeSpan timeSpan) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeIn(System.DateTimeKind expectedKind, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeLessThan(System.TimeSpan timeSpan) { }
        public AwesomeAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeMoreThan(System.TimeSpan timeSpan) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOnOrAfter(System.DateTime expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOnOrBefore(System.DateTime expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateTime[] validValues) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateTime?[] validValues) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTime> validValues, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTime?> validValues, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeSameDateAs(System.DateTime expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeWithin(System.TimeSpan timeSpan) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveDay(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveHour(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveMinute(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveMonth(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveSecond(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveYear(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(System.DateTime unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(System.DateTime? unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeAfter(System.DateTime unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeBefore(System.DateTime unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.DateTime distantTime, System.TimeSpan precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeIn(System.DateTimeKind unexpectedKind, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeOnOrAfter(System.DateTime unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeOnOrBefore(System.DateTime unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeSameDateAs(System.DateTime unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveDay(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveHour(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveMinute(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveMonth(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveSecond(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveYear(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class DateTimeOffsetAssertions : AwesomeAssertions.Primitives.DateTimeOffsetAssertions<AwesomeAssertions.Primitives.DateTimeOffsetAssertions>
    {
        public DateTimeOffsetAssertions(System.DateTimeOffset? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class DateTimeOffsetAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>
    {
        public DateTimeOffsetAssertions(System.DateTimeOffset? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public System.DateTimeOffset? Subject { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(System.DateTimeOffset expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(System.DateTimeOffset? expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeAfter(System.DateTimeOffset expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeAtLeast(System.TimeSpan timeSpan) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeBefore(System.DateTimeOffset expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeCloseTo(System.DateTimeOffset nearbyTime, System.TimeSpan precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeExactly(System.TimeSpan timeSpan) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeExactly(System.DateTimeOffset expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeExactly(System.DateTimeOffset? expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeLessThan(System.TimeSpan timeSpan) { }
        public AwesomeAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeMoreThan(System.TimeSpan timeSpan) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOnOrAfter(System.DateTimeOffset expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOnOrBefore(System.DateTimeOffset expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateTimeOffset[] validValues) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateTimeOffset?[] validValues) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTimeOffset> validValues, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTimeOffset?> validValues, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeSameDateAs(System.DateTimeOffset expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeWithin(System.TimeSpan timeSpan) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveDay(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveHour(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveMinute(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveMonth(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveOffset(System.TimeSpan expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveSecond(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveYear(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(System.DateTimeOffset unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(System.DateTimeOffset? unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeAfter(System.DateTimeOffset unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeBefore(System.DateTimeOffset unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.DateTimeOffset distantTime, System.TimeSpan precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeExactly(System.DateTimeOffset unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeExactly(System.DateTimeOffset? unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeOnOrAfter(System.DateTimeOffset unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeOnOrBefore(System.DateTimeOffset unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeSameDateAs(System.DateTimeOffset unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveDay(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveHour(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveMinute(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveMonth(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveOffset(System.TimeSpan unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveSecond(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveYear(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class DateTimeOffsetRangeAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>
    {
        protected DateTimeOffsetRangeAssertions(TAssertions parentAssertions, AwesomeAssertions.Execution.AssertionChain assertionChain, System.DateTimeOffset? subject, AwesomeAssertions.Primitives.TimeSpanCondition condition, System.TimeSpan timeSpan) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> After(System.DateTimeOffset target, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Before(System.DateTimeOffset target, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
    }
    public class DateTimeRangeAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.DateTimeAssertions<TAssertions>
    {
        protected DateTimeRangeAssertions(TAssertions parentAssertions, AwesomeAssertions.Execution.AssertionChain assertionChain, System.DateTime? subject, AwesomeAssertions.Primitives.TimeSpanCondition condition, System.TimeSpan timeSpan) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> After(System.DateTime target, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Before(System.DateTime target, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
    }
    public class EnumAssertions<TEnum> : AwesomeAssertions.Primitives.EnumAssertions<TEnum, AwesomeAssertions.Primitives.EnumAssertions<TEnum>>
        where TEnum :  struct, System.Enum
    {
        public EnumAssertions(TEnum subject, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class EnumAssertions<TEnum, TAssertions>
        where TEnum :  struct, System.Enum
        where TAssertions : AwesomeAssertions.Primitives.EnumAssertions<TEnum, TAssertions>
    {
        public EnumAssertions(TEnum subject, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public TEnum? Subject { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(TEnum expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(TEnum? expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeDefined([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(params TEnum[] validValues) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TEnum> validValues, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveFlag(TEnum expectedFlag, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveSameNameAs<T>(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where T :  struct, System.Enum { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveSameValueAs<T>(T expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where T :  struct, System.Enum { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveValue(decimal expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<TEnum?, bool>> predicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(TEnum unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(TEnum? unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeDefined([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveFlag(TEnum unexpectedFlag, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveSameNameAs<T>(T unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where T :  struct, System.Enum { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveSameValueAs<T>(T unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where T :  struct, System.Enum { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveValue(decimal unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class GuidAssertions : AwesomeAssertions.Primitives.GuidAssertions<AwesomeAssertions.Primitives.GuidAssertions>
    {
        public GuidAssertions(System.Guid? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class GuidAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.GuidAssertions<TAssertions>
    {
        public GuidAssertions(System.Guid? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public System.Guid? Subject { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(System.Guid expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEmpty([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(System.Guid unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(string unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeEmpty([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class NullableBooleanAssertions : AwesomeAssertions.Primitives.NullableBooleanAssertions<AwesomeAssertions.Primitives.NullableBooleanAssertions>
    {
        public NullableBooleanAssertions(bool? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableBooleanAssertions<TAssertions> : AwesomeAssertions.Primitives.BooleanAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.NullableBooleanAssertions<TAssertions>
    {
        public NullableBooleanAssertions(bool? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(bool? expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(bool? unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeFalse([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeTrue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class NullableDateOnlyAssertions : AwesomeAssertions.Primitives.NullableDateOnlyAssertions<AwesomeAssertions.Primitives.NullableDateOnlyAssertions>
    {
        public NullableDateOnlyAssertions(System.DateOnly? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableDateOnlyAssertions<TAssertions> : AwesomeAssertions.Primitives.DateOnlyAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.NullableDateOnlyAssertions<TAssertions>
    {
        public NullableDateOnlyAssertions(System.DateOnly? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class NullableDateTimeAssertions : AwesomeAssertions.Primitives.NullableDateTimeAssertions<AwesomeAssertions.Primitives.NullableDateTimeAssertions>
    {
        public NullableDateTimeAssertions(System.DateTime? expected, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableDateTimeAssertions<TAssertions> : AwesomeAssertions.Primitives.DateTimeAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.NullableDateTimeAssertions<TAssertions>
    {
        public NullableDateTimeAssertions(System.DateTime? expected, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class NullableDateTimeOffsetAssertions : AwesomeAssertions.Primitives.NullableDateTimeOffsetAssertions<AwesomeAssertions.Primitives.NullableDateTimeOffsetAssertions>
    {
        public NullableDateTimeOffsetAssertions(System.DateTimeOffset? expected, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableDateTimeOffsetAssertions<TAssertions> : AwesomeAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.NullableDateTimeOffsetAssertions<TAssertions>
    {
        public NullableDateTimeOffsetAssertions(System.DateTimeOffset? expected, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class NullableEnumAssertions<TEnum> : AwesomeAssertions.Primitives.NullableEnumAssertions<TEnum, AwesomeAssertions.Primitives.NullableEnumAssertions<TEnum>>
        where TEnum :  struct, System.Enum
    {
        public NullableEnumAssertions(TEnum? subject, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableEnumAssertions<TEnum, TAssertions> : AwesomeAssertions.Primitives.EnumAssertions<TEnum, TAssertions>
        where TEnum :  struct, System.Enum
        where TAssertions : AwesomeAssertions.Primitives.NullableEnumAssertions<TEnum, TAssertions>
    {
        public NullableEnumAssertions(TEnum? subject, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, TEnum> HaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, TEnum> NotBeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class NullableGuidAssertions : AwesomeAssertions.Primitives.NullableGuidAssertions<AwesomeAssertions.Primitives.NullableGuidAssertions>
    {
        public NullableGuidAssertions(System.Guid? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableGuidAssertions<TAssertions> : AwesomeAssertions.Primitives.GuidAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.NullableGuidAssertions<TAssertions>
    {
        public NullableGuidAssertions(System.Guid? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(System.Guid? expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class NullableSimpleTimeSpanAssertions : AwesomeAssertions.Primitives.NullableSimpleTimeSpanAssertions<AwesomeAssertions.Primitives.NullableSimpleTimeSpanAssertions>
    {
        public NullableSimpleTimeSpanAssertions(System.TimeSpan? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableSimpleTimeSpanAssertions<TAssertions> : AwesomeAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.NullableSimpleTimeSpanAssertions<TAssertions>
    {
        public NullableSimpleTimeSpanAssertions(System.TimeSpan? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(System.TimeSpan? expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class NullableTimeOnlyAssertions : AwesomeAssertions.Primitives.NullableTimeOnlyAssertions<AwesomeAssertions.Primitives.NullableTimeOnlyAssertions>
    {
        public NullableTimeOnlyAssertions(System.TimeOnly? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class NullableTimeOnlyAssertions<TAssertions> : AwesomeAssertions.Primitives.TimeOnlyAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.NullableTimeOnlyAssertions<TAssertions>
    {
        public NullableTimeOnlyAssertions(System.TimeOnly? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveValue([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class ObjectAssertions : AwesomeAssertions.Primitives.ObjectAssertions<object, AwesomeAssertions.Primitives.ObjectAssertions>
    {
        public ObjectAssertions(object value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Primitives.ObjectAssertions> Be<TExpectation>(TExpectation expected, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Primitives.ObjectAssertions> BeOneOf<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> validValues, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Primitives.ObjectAssertions> NotBe<TExpectation>(TExpectation unexpected, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class ObjectAssertions<TSubject, TAssertions> : AwesomeAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.ObjectAssertions<TSubject, TAssertions>
    {
        public ObjectAssertions(TSubject value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(TSubject expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(TSubject expected, System.Collections.Generic.IEqualityComparer<TSubject> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>, AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(params TSubject[] validValues) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TSubject> validValues, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TSubject> validValues, System.Collections.Generic.IEqualityComparer<TSubject> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(TSubject unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(TSubject unexpected, System.Collections.Generic.IEqualityComparer<TSubject> comparer, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(TExpectation unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(TExpectation unexpected, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>, AwesomeAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public abstract class ReferenceTypeAssertions<TSubject, TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
    {
        protected ReferenceTypeAssertions(TSubject subject, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        protected abstract string Identifier { get; }
        public TSubject Subject { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> BeAssignableTo(System.Type type, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, T> BeAssignableTo<T>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOfType(System.Type expectedType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, T> BeOfType<T>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeSameAs(TSubject expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<TSubject, bool>> predicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Match<T>(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where T : TSubject { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeAssignableTo(System.Type type, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeAssignableTo<T>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeNull([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeOfType(System.Type unexpectedType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeOfType<T>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeSameAs(TSubject unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Satisfy<T>(System.Action<T> assertion)
            where T : TSubject { }
    }
    public class SimpleTimeSpanAssertions : AwesomeAssertions.Primitives.SimpleTimeSpanAssertions<AwesomeAssertions.Primitives.SimpleTimeSpanAssertions>
    {
        public SimpleTimeSpanAssertions(System.TimeSpan? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class SimpleTimeSpanAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions>
    {
        public SimpleTimeSpanAssertions(System.TimeSpan? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public System.TimeSpan? Subject { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(System.TimeSpan expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeCloseTo(System.TimeSpan nearbyTime, System.TimeSpan precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeGreaterThan(System.TimeSpan expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(System.TimeSpan expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeLessThan(System.TimeSpan expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(System.TimeSpan expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNegative([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BePositive([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(System.TimeSpan unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.TimeSpan distantTime, System.TimeSpan precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class StringAssertions : AwesomeAssertions.Primitives.StringAssertions<AwesomeAssertions.Primitives.StringAssertions>
    {
        public StringAssertions(string value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class StringAssertions<TAssertions> : AwesomeAssertions.Primitives.ReferenceTypeAssertions<string, TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.StringAssertions<TAssertions>
    {
        public StringAssertions(string value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEmpty([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo(string expected, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<string>, AwesomeAssertions.Equivalency.EquivalencyOptions<string>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeLowerCased([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNullOrEmpty([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeNullOrWhiteSpace([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(params string[] validValues) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<string> validValues, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, T> BeParsableInto<T>(string because = "", params object[] becauseArgs)
            where T : System.IParsable<T> { }
        public AwesomeAssertions.AndWhichConstraint<TAssertions, T> BeParsableInto<T>(System.IFormatProvider formatProvider, string because = "", params object[] becauseArgs)
            where T : System.IParsable<T> { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeUpperCased([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Contain(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Contain(string expected, AwesomeAssertions.OccurrenceConstraint occurrenceConstraint, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainAll(params string[] values) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainAll(System.Collections.Generic.IEnumerable<string> values, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainAny(params string[] values) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainAny(System.Collections.Generic.IEnumerable<string> values, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, AwesomeAssertions.OccurrenceConstraint occurrenceConstraint, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<string>, AwesomeAssertions.Equivalency.EquivalencyOptions<string>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, AwesomeAssertions.OccurrenceConstraint occurrenceConstraint, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<string>, AwesomeAssertions.Equivalency.EquivalencyOptions<string>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> EndWith(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> EndWithEquivalentOf(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> EndWithEquivalentOf(string expected, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<string>, AwesomeAssertions.Equivalency.EquivalencyOptions<string>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveLength(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Match(string wildcardPattern, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> MatchEquivalentOf(string wildcardPattern, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> MatchEquivalentOf(string wildcardPattern, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<string>, AwesomeAssertions.Equivalency.EquivalencyOptions<string>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> MatchRegex(System.Text.RegularExpressions.Regex regularExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> MatchRegex([System.Diagnostics.CodeAnalysis.StringSyntax("Regex")] string regularExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> MatchRegex(System.Text.RegularExpressions.Regex regularExpression, AwesomeAssertions.OccurrenceConstraint occurrenceConstraint, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> MatchRegex([System.Diagnostics.CodeAnalysis.StringSyntax("Regex")] string regularExpression, AwesomeAssertions.OccurrenceConstraint occurrenceConstraint, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(string unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeEmpty([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(string unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(string unexpected, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<string>, AwesomeAssertions.Equivalency.EquivalencyOptions<string>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeLowerCased([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeNullOrEmpty([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeNullOrWhiteSpace([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeParsableInto<T>(string because = "", params object[] becauseArgs)
            where T : System.IParsable<T> { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeParsableInto<T>(System.IFormatProvider formatProvider, string because = "", params object[] becauseArgs)
            where T : System.IParsable<T> { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeUpperCased([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContain(string unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainAll(params string[] values) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainAll(System.Collections.Generic.IEnumerable<string> values, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainAny(params string[] values) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainAny(System.Collections.Generic.IEnumerable<string> values, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainEquivalentOf(string unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotContainEquivalentOf(string unexpected, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<string>, AwesomeAssertions.Equivalency.EquivalencyOptions<string>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotEndWith(string unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotEndWithEquivalentOf(string unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotEndWithEquivalentOf(string unexpected, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<string>, AwesomeAssertions.Equivalency.EquivalencyOptions<string>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotMatch(string wildcardPattern, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotMatchEquivalentOf(string wildcardPattern, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotMatchEquivalentOf(string wildcardPattern, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<string>, AwesomeAssertions.Equivalency.EquivalencyOptions<string>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotMatchRegex(System.Text.RegularExpressions.Regex regularExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotMatchRegex([System.Diagnostics.CodeAnalysis.StringSyntax("Regex")] string regularExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotStartWith(string unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotStartWithEquivalentOf(string unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotStartWithEquivalentOf(string unexpected, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<string>, AwesomeAssertions.Equivalency.EquivalencyOptions<string>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> StartWith(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> StartWithEquivalentOf(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> StartWithEquivalentOf(string expected, System.Func<AwesomeAssertions.Equivalency.EquivalencyOptions<string>, AwesomeAssertions.Equivalency.EquivalencyOptions<string>> config, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class TimeOnlyAssertions : AwesomeAssertions.Primitives.TimeOnlyAssertions<AwesomeAssertions.Primitives.TimeOnlyAssertions>
    {
        public TimeOnlyAssertions(System.TimeOnly? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class TimeOnlyAssertions<TAssertions>
        where TAssertions : AwesomeAssertions.Primitives.TimeOnlyAssertions<TAssertions>
    {
        public TimeOnlyAssertions(System.TimeOnly? value, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public System.TimeOnly? Subject { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(System.TimeOnly expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> Be(System.TimeOnly? expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeAfter(System.TimeOnly expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeBefore(System.TimeOnly expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeCloseTo(System.TimeOnly nearbyTime, System.TimeSpan precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOnOrAfter(System.TimeOnly expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOnOrBefore(System.TimeOnly expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(params System.TimeOnly[] validValues) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(params System.TimeOnly?[] validValues) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.TimeOnly> validValues, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.TimeOnly?> validValues, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveHours(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveMilliseconds(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveMinutes(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveSeconds(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(System.TimeOnly unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBe(System.TimeOnly? unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeAfter(System.TimeOnly unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeBefore(System.TimeOnly unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.TimeOnly distantTime, System.TimeSpan precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeOnOrAfter(System.TimeOnly unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeOnOrBefore(System.TimeOnly unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveHours(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveMilliseconds(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveMinutes(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveSeconds(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public enum TimeSpanCondition
    {
        MoreThan = 0,
        AtLeast = 1,
        Exactly = 2,
        Within = 3,
        LessThan = 4,
    }
}
namespace AwesomeAssertions.Specialized
{
    public class ActionAssertions : AwesomeAssertions.Specialized.DelegateAssertions<System.Action, AwesomeAssertions.Specialized.ActionAssertions>
    {
        public ActionAssertions(System.Action subject, AwesomeAssertions.Specialized.IExtractExceptions extractor, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public ActionAssertions(System.Action subject, AwesomeAssertions.Specialized.IExtractExceptions extractor, AwesomeAssertions.Execution.AssertionChain assertionChain, AwesomeAssertions.Common.IClock clock) { }
        protected override string Identifier { get; }
        protected override void InvokeSubject() { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Specialized.ActionAssertions> NotThrow([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Specialized.ActionAssertions> NotThrowAfter(System.TimeSpan waitTime, System.TimeSpan pollInterval, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class AsyncFunctionAssertions<TTask, TAssertions> : AwesomeAssertions.Specialized.DelegateAssertionsBase<System.Func<TTask>, TAssertions>
        where TTask : System.Threading.Tasks.Task
        where TAssertions : AwesomeAssertions.Specialized.AsyncFunctionAssertions<TTask, TAssertions>
    {
        protected AsyncFunctionAssertions(System.Func<TTask> subject, AwesomeAssertions.Specialized.IExtractExceptions extractor, AwesomeAssertions.Execution.AssertionChain assertionChain, AwesomeAssertions.Common.IClock clock) { }
        protected override string Identifier { get; }
        public System.Threading.Tasks.Task<AwesomeAssertions.AndConstraint<TAssertions>> NotCompleteWithinAsync(System.TimeSpan timeSpan, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<AwesomeAssertions.AndConstraint<TAssertions>> NotThrowAsync<TException>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TException>> ThrowAsync<TException>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TException>> ThrowExactlyAsync<TException>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public System.Threading.Tasks.Task<AwesomeAssertions.Specialized.ExceptionAssertions<TException>> ThrowWithinAsync<TException>(System.TimeSpan timeSpan, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
    }
    public abstract class DelegateAssertionsBase<TDelegate, TAssertions> : AwesomeAssertions.Primitives.ReferenceTypeAssertions<TDelegate, AwesomeAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>>
        where TDelegate : System.Delegate
        where TAssertions : AwesomeAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>
    {
        protected AwesomeAssertions.AndConstraint<TAssertions> NotThrowInternal(System.Exception exception, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because, object[] becauseArgs) { }
        protected AwesomeAssertions.AndConstraint<TAssertions> NotThrowInternal<TException>(System.Exception exception, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because, object[] becauseArgs)
            where TException : System.Exception { }
        protected AwesomeAssertions.Specialized.ExceptionAssertions<TException> ThrowInternal<TException>(System.Exception exception, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because, object[] becauseArgs)
            where TException : System.Exception { }
    }
    public abstract class DelegateAssertions<TDelegate, TAssertions> : AwesomeAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>
        where TDelegate : System.Delegate
        where TAssertions : AwesomeAssertions.Specialized.DelegateAssertions<TDelegate, TAssertions>
    {
        protected DelegateAssertions(TDelegate @delegate, AwesomeAssertions.Specialized.IExtractExceptions extractor, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected abstract void InvokeSubject();
        public AwesomeAssertions.AndConstraint<TAssertions> NotThrow<TException>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public AwesomeAssertions.Specialized.ExceptionAssertions<TException> Throw<TException>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
        public AwesomeAssertions.Specialized.ExceptionAssertions<TException> ThrowExactly<TException>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TException : System.Exception { }
    }
    public class ExceptionAssertions<TException> : AwesomeAssertions.Primitives.ReferenceTypeAssertions<System.Collections.Generic.IEnumerable<TException>, AwesomeAssertions.Specialized.ExceptionAssertions<TException>>
        where TException : System.Exception
    {
        public ExceptionAssertions(System.Collections.Generic.IEnumerable<TException> exceptions, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public TException And { get; }
        protected override string Identifier { get; }
        public TException Which { get; }
        public AwesomeAssertions.Specialized.ExceptionAssertions<TException> Where(System.Linq.Expressions.Expression<System.Func<TException, bool>> exceptionExpression, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.Specialized.ExceptionAssertions<System.Exception> WithInnerException(System.Type innerException, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public virtual AwesomeAssertions.Specialized.ExceptionAssertions<TInnerException> WithInnerException<TInnerException>(string because = "", params object[] becauseArgs)
            where TInnerException : System.Exception { }
        public AwesomeAssertions.Specialized.ExceptionAssertions<System.Exception> WithInnerExceptionExactly(System.Type innerException, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public virtual AwesomeAssertions.Specialized.ExceptionAssertions<TInnerException> WithInnerExceptionExactly<TInnerException>(string because = "", params object[] becauseArgs)
            where TInnerException : System.Exception { }
        public virtual AwesomeAssertions.Specialized.ExceptionAssertions<TException> WithMessage(string expectedWildcardPattern, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class ExecutionTime
    {
        public ExecutionTime(System.Action action, AwesomeAssertions.Common.StartTimer createTimer) { }
        public ExecutionTime(System.Func<System.Threading.Tasks.Task> action, AwesomeAssertions.Common.StartTimer createTimer) { }
        protected ExecutionTime(System.Action action, string actionDescription, AwesomeAssertions.Common.StartTimer createTimer) { }
        protected ExecutionTime(System.Func<System.Threading.Tasks.Task> action, string actionDescription, AwesomeAssertions.Common.StartTimer createTimer) { }
    }
    public class ExecutionTimeAssertions
    {
        public ExecutionTimeAssertions(AwesomeAssertions.Specialized.ExecutionTime executionTime, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Specialized.ExecutionTimeAssertions> BeCloseTo(System.TimeSpan expectedDuration, System.TimeSpan precision, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Specialized.ExecutionTimeAssertions> BeGreaterThan(System.TimeSpan minDuration, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Specialized.ExecutionTimeAssertions> BeGreaterThanOrEqualTo(System.TimeSpan minDuration, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Specialized.ExecutionTimeAssertions> BeLessThan(System.TimeSpan maxDuration, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Specialized.ExecutionTimeAssertions> BeLessThanOrEqualTo(System.TimeSpan maxDuration, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
    }
    public class FunctionAssertions<T> : AwesomeAssertions.Specialized.DelegateAssertions<System.Func<T>, AwesomeAssertions.Specialized.FunctionAssertions<T>>
    {
        public FunctionAssertions(System.Func<T> subject, AwesomeAssertions.Specialized.IExtractExceptions extractor, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public FunctionAssertions(System.Func<T> subject, AwesomeAssertions.Specialized.IExtractExceptions extractor, AwesomeAssertions.Execution.AssertionChain assertionChain, AwesomeAssertions.Common.IClock clock) { }
        protected override string Identifier { get; }
        protected override void InvokeSubject() { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Specialized.FunctionAssertions<T>, T> NotThrow([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Specialized.FunctionAssertions<T>, T> NotThrowAfter(System.TimeSpan waitTime, System.TimeSpan pollInterval, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class GenericAsyncFunctionAssertions<TResult> : AwesomeAssertions.Specialized.AsyncFunctionAssertions<System.Threading.Tasks.Task<TResult>, AwesomeAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>>
    {
        public GenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task<TResult>> subject, AwesomeAssertions.Specialized.IExtractExceptions extractor, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public GenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task<TResult>> subject, AwesomeAssertions.Specialized.IExtractExceptions extractor, AwesomeAssertions.Execution.AssertionChain assertionChain, AwesomeAssertions.Common.IClock clock) { }
        public System.Threading.Tasks.Task<AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> CompleteWithinAsync(System.TimeSpan timeSpan, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> NotThrowAfterAsync(System.TimeSpan waitTime, System.TimeSpan pollInterval, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> NotThrowAsync([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public interface IExtractExceptions
    {
        System.Collections.Generic.IEnumerable<T> OfType<T>(System.Exception actualException)
            where T : System.Exception;
    }
    public class MemberExecutionTime<T> : AwesomeAssertions.Specialized.ExecutionTime
    {
        public MemberExecutionTime(T subject, System.Linq.Expressions.Expression<System.Action<T>> action, AwesomeAssertions.Common.StartTimer createTimer) { }
    }
    public class NonGenericAsyncFunctionAssertions : AwesomeAssertions.Specialized.AsyncFunctionAssertions<System.Threading.Tasks.Task, AwesomeAssertions.Specialized.NonGenericAsyncFunctionAssertions>
    {
        public NonGenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task> subject, AwesomeAssertions.Specialized.IExtractExceptions extractor, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public NonGenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task> subject, AwesomeAssertions.Specialized.IExtractExceptions extractor, AwesomeAssertions.Execution.AssertionChain assertionChain, AwesomeAssertions.Common.IClock clock) { }
        public System.Threading.Tasks.Task<AwesomeAssertions.AndConstraint<AwesomeAssertions.Specialized.NonGenericAsyncFunctionAssertions>> CompleteWithinAsync(System.TimeSpan timeSpan, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<AwesomeAssertions.AndConstraint<AwesomeAssertions.Specialized.NonGenericAsyncFunctionAssertions>> NotThrowAfterAsync(System.TimeSpan waitTime, System.TimeSpan pollInterval, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<AwesomeAssertions.AndConstraint<AwesomeAssertions.Specialized.NonGenericAsyncFunctionAssertions>> NotThrowAsync([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class TaskCompletionSourceAssertions : AwesomeAssertions.Specialized.TaskCompletionSourceAssertionsBase
    {
        public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource tcs, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource tcs, AwesomeAssertions.Execution.AssertionChain assertionChain, AwesomeAssertions.Common.IClock clock) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public System.Threading.Tasks.Task<AwesomeAssertions.AndConstraint<AwesomeAssertions.Specialized.TaskCompletionSourceAssertions>> CompleteWithinAsync(System.TimeSpan timeSpan, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<AwesomeAssertions.AndConstraint<AwesomeAssertions.Specialized.TaskCompletionSourceAssertions>> NotCompleteWithinAsync(System.TimeSpan timeSpan, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class TaskCompletionSourceAssertionsBase
    {
        protected TaskCompletionSourceAssertionsBase(AwesomeAssertions.Common.IClock clock) { }
        public override bool Equals(object obj) { }
    }
    public class TaskCompletionSourceAssertions<T> : AwesomeAssertions.Specialized.TaskCompletionSourceAssertionsBase
    {
        public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource<T> tcs, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource<T> tcs, AwesomeAssertions.Execution.AssertionChain assertionChain, AwesomeAssertions.Common.IClock clock) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public System.Threading.Tasks.Task<AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> CompleteWithinAsync(System.TimeSpan timeSpan, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public System.Threading.Tasks.Task<AwesomeAssertions.AndConstraint<AwesomeAssertions.Specialized.TaskCompletionSourceAssertions<T>>> NotCompleteWithinAsync(System.TimeSpan timeSpan, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
}
namespace AwesomeAssertions.Streams
{
    public class BufferedStreamAssertions : AwesomeAssertions.Streams.BufferedStreamAssertions<AwesomeAssertions.Streams.BufferedStreamAssertions>
    {
        public BufferedStreamAssertions(System.IO.BufferedStream stream, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class BufferedStreamAssertions<TAssertions> : AwesomeAssertions.Streams.StreamAssertions<System.IO.BufferedStream, TAssertions>
        where TAssertions : AwesomeAssertions.Streams.BufferedStreamAssertions<TAssertions>
    {
        public BufferedStreamAssertions(System.IO.BufferedStream stream, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveBufferSize(int expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveBufferSize(int unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class StreamAssertions : AwesomeAssertions.Streams.StreamAssertions<System.IO.Stream, AwesomeAssertions.Streams.StreamAssertions>
    {
        public StreamAssertions(System.IO.Stream stream, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class StreamAssertions<TSubject, TAssertions> : AwesomeAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
        where TSubject : System.IO.Stream
        where TAssertions : AwesomeAssertions.Streams.StreamAssertions<TSubject, TAssertions>
    {
        public StreamAssertions(TSubject stream, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> BeReadOnly([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeReadable([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeSeekable([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeWritable([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> BeWriteOnly([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveLength(long expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HavePosition(long expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeReadOnly([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeReadable([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeSeekable([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeWritable([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeWriteOnly([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveLength(long unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHavePosition(long unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
}
namespace AwesomeAssertions.Types
{
    public static class AllTypes
    {
        public static AwesomeAssertions.Types.TypeSelector From(System.Reflection.Assembly assembly) { }
    }
    public class AssemblyAssertions : AwesomeAssertions.Primitives.ReferenceTypeAssertions<System.Reflection.Assembly, AwesomeAssertions.Types.AssemblyAssertions>
    {
        public AssemblyAssertions(System.Reflection.Assembly assembly, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.AssemblyAssertions> BeSignedWithPublicKey(string publicKey, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.AssemblyAssertions> BeUnsigned([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.AssemblyAssertions, System.Type> DefineType(string @namespace, string name, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.AssemblyAssertions> NotReference(System.Reflection.Assembly assembly, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.AssemblyAssertions> Reference(System.Reflection.Assembly assembly, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class ConstructorInfoAssertions : AwesomeAssertions.Types.MethodBaseAssertions<System.Reflection.ConstructorInfo, AwesomeAssertions.Types.ConstructorInfoAssertions>
    {
        public ConstructorInfoAssertions(System.Reflection.ConstructorInfo constructorInfo, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
    }
    public abstract class MemberInfoAssertions<TSubject, TAssertions> : AwesomeAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
        where TSubject : System.Reflection.MemberInfo
        where TAssertions : AwesomeAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>
    {
        protected MemberInfoAssertions(TSubject subject, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>, TAttribute> BeDecoratedWith<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>, TAttribute> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeDecoratedWith<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
    }
    public abstract class MethodBaseAssertions<TSubject, TAssertions> : AwesomeAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>
        where TSubject : System.Reflection.MethodBase
        where TAssertions : AwesomeAssertions.Types.MethodBaseAssertions<TSubject, TAssertions>
    {
        protected MethodBaseAssertions(TSubject subject, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        public AwesomeAssertions.AndConstraint<TAssertions> HaveAccessModifier(AwesomeAssertions.Common.CSharpAccessModifier accessModifier, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotHaveAccessModifier(AwesomeAssertions.Common.CSharpAccessModifier accessModifier, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class MethodInfoAssertions : AwesomeAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, AwesomeAssertions.Types.MethodInfoAssertions>
    {
        public MethodInfoAssertions(System.Reflection.MethodInfo methodInfo, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoAssertions> BeAsync([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoAssertions> BeVirtual([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoAssertions> NotBeAsync([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoAssertions> NotBeVirtual([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, AwesomeAssertions.Types.MethodInfoAssertions>> NotReturn(System.Type returnType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, AwesomeAssertions.Types.MethodInfoAssertions>> NotReturn<TReturn>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, AwesomeAssertions.Types.MethodInfoAssertions>> NotReturnVoid([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, AwesomeAssertions.Types.MethodInfoAssertions>> Return(System.Type returnType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, AwesomeAssertions.Types.MethodInfoAssertions>> Return<TReturn>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, AwesomeAssertions.Types.MethodInfoAssertions>> ReturnVoid([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class MethodInfoSelector : System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>, System.Collections.IEnumerable
    {
        public MethodInfoSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }
        public MethodInfoSelector(System.Type type) { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatArePublicOrInternal { get; }
        public AwesomeAssertions.Types.MethodInfoSelector ThatDoNotReturnVoid { get; }
        public AwesomeAssertions.Types.MethodInfoSelector ThatReturnVoid { get; }
        public System.Collections.Generic.IEnumerator<System.Reflection.MethodInfo> GetEnumerator() { }
        public AwesomeAssertions.Types.TypeSelector ReturnTypes() { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatAreAbstract() { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatAreAsync() { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatAreDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatAreDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatAreNotAbstract() { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatAreNotAsync() { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatAreNotDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatAreNotStatic() { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatAreNotVirtual() { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatAreStatic() { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatAreVirtual() { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatDoNotReturn<TReturn>() { }
        public AwesomeAssertions.Types.MethodInfoSelector ThatReturn<TReturn>() { }
        public System.Reflection.MethodInfo[] ToArray() { }
    }
    public class MethodInfoSelectorAssertions
    {
        public MethodInfoSelectorAssertions(AwesomeAssertions.Execution.AssertionChain assertionChain, params System.Reflection.MethodInfo[] methods) { }
        protected string Context { get; }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> SubjectMethods { get; }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoSelectorAssertions> Be(AwesomeAssertions.Common.CSharpAccessModifier accessModifier, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoSelectorAssertions> BeAsync([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoSelectorAssertions> BeDecoratedWith<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoSelectorAssertions> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoSelectorAssertions> BeVirtual([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoSelectorAssertions> NotBe(AwesomeAssertions.Common.CSharpAccessModifier accessModifier, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoSelectorAssertions> NotBeAsync([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.MethodInfoSelectorAssertions> NotBeVirtual([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class PropertyInfoAssertions : AwesomeAssertions.Types.MemberInfoAssertions<System.Reflection.PropertyInfo, AwesomeAssertions.Types.PropertyInfoAssertions>
    {
        public PropertyInfoAssertions(System.Reflection.PropertyInfo propertyInfo, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoAssertions> BeReadable([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoAssertions> BeReadable(AwesomeAssertions.Common.CSharpAccessModifier accessModifier, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoAssertions> BeVirtual([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoAssertions> BeWritable([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoAssertions> BeWritable(AwesomeAssertions.Common.CSharpAccessModifier accessModifier, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoAssertions> NotBeReadable([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoAssertions> NotBeVirtual([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoAssertions> NotBeWritable([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoAssertions> NotReturn(System.Type propertyType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoAssertions> NotReturn<TReturn>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoAssertions> Return(System.Type propertyType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoAssertions> Return<TReturn>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class PropertyInfoSelector : System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo>, System.Collections.IEnumerable
    {
        public PropertyInfoSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }
        public PropertyInfoSelector(System.Type type) { }
        public AwesomeAssertions.Types.PropertyInfoSelector ThatAreAbstract { get; }
        public AwesomeAssertions.Types.PropertyInfoSelector ThatAreNotAbstract { get; }
        public AwesomeAssertions.Types.PropertyInfoSelector ThatAreNotStatic { get; }
        public AwesomeAssertions.Types.PropertyInfoSelector ThatAreNotVirtual { get; }
        public AwesomeAssertions.Types.PropertyInfoSelector ThatArePublicOrInternal { get; }
        public AwesomeAssertions.Types.PropertyInfoSelector ThatAreStatic { get; }
        public AwesomeAssertions.Types.PropertyInfoSelector ThatAreVirtual { get; }
        public System.Collections.Generic.IEnumerator<System.Reflection.PropertyInfo> GetEnumerator() { }
        public AwesomeAssertions.Types.PropertyInfoSelector NotOfType<TReturn>() { }
        public AwesomeAssertions.Types.PropertyInfoSelector OfType<TReturn>() { }
        public AwesomeAssertions.Types.TypeSelector ReturnTypes() { }
        public AwesomeAssertions.Types.PropertyInfoSelector ThatAreDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.Types.PropertyInfoSelector ThatAreDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.Types.PropertyInfoSelector ThatAreNotDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.Types.PropertyInfoSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public System.Reflection.PropertyInfo[] ToArray() { }
    }
    public class PropertyInfoSelectorAssertions
    {
        public PropertyInfoSelectorAssertions(AwesomeAssertions.Execution.AssertionChain assertionChain, params System.Reflection.PropertyInfo[] properties) { }
        protected string Context { get; }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> SubjectProperties { get; }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoSelectorAssertions> BeDecoratedWith<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoSelectorAssertions> BeVirtual([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoSelectorAssertions> BeWritable([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoSelectorAssertions> NotBeVirtual([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.PropertyInfoSelectorAssertions> NotBeWritable([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class TypeAssertions : AwesomeAssertions.Primitives.ReferenceTypeAssertions<System.Type, AwesomeAssertions.Types.TypeAssertions>
    {
        public TypeAssertions(System.Type type, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> Be(System.Type expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> Be<TExpected>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> BeAbstract([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public new AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> BeAssignableTo(System.Type type, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public new AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> BeAssignableTo<T>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> BeDerivedFrom(System.Type baseType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> BeDerivedFrom<TBaseClass>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TBaseClass :  class { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> BeSealed([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> BeStatic([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> HaveAccessModifier(AwesomeAssertions.Common.CSharpAccessModifier accessModifier, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveConstructor(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveDefaultConstructor([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator(System.Type sourceType, System.Type targetType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator<TSource, TTarget>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> HaveExplicitMethod(System.Type interfaceType, string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> HaveExplicitMethod<TInterface>(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> HaveExplicitProperty(System.Type interfaceType, string name, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> HaveExplicitProperty<TInterface>(string name, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator(System.Type sourceType, System.Type targetType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator<TSource, TTarget>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveIndexer(System.Type indexerType, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveMethod(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveProperty(string name, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveProperty(System.Type propertyType, string name, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveProperty<TProperty>(string name, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> Implement(System.Type interfaceType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> Implement<TInterface>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotBe(System.Type unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotBe<TUnexpected>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotBeAbstract([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public new AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotBeAssignableTo(System.Type type, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public new AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotBeAssignableTo<T>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotBeDecoratedWith<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotBeDecoratedWithOrInherit<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotBeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotBeDerivedFrom(System.Type baseType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotBeDerivedFrom<TBaseClass>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TBaseClass :  class { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotBeSealed([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotBeStatic([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotHaveAccessModifier(AwesomeAssertions.Common.CSharpAccessModifier accessModifier, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> NotHaveConstructor(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> NotHaveDefaultConstructor([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotHaveExplicitConversionOperator(System.Type sourceType, System.Type targetType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotHaveExplicitConversionOperator<TSource, TTarget>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotHaveExplicitMethod(System.Type interfaceType, string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotHaveExplicitMethod<TInterface>(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotHaveExplicitProperty(System.Type interfaceType, string name, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotHaveExplicitProperty<TInterface>(string name, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TInterface :  class { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotHaveImplicitConversionOperator(System.Type sourceType, System.Type targetType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotHaveImplicitConversionOperator<TSource, TTarget>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotHaveIndexer(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotHaveMethod(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotHaveProperty(string name, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotImplement(System.Type interfaceType, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeAssertions> NotImplement<TInterface>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TInterface :  class { }
    }
    public class TypeSelector : System.Collections.Generic.IEnumerable<System.Type>, System.Collections.IEnumerable
    {
        public TypeSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }
        public TypeSelector(System.Type type) { }
        public System.Collections.Generic.IEnumerator<System.Type> GetEnumerator() { }
        public AwesomeAssertions.Types.TypeSelector ThatAreAbstract() { }
        public AwesomeAssertions.Types.TypeSelector ThatAreClasses() { }
        public AwesomeAssertions.Types.TypeSelector ThatAreDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.Types.TypeSelector ThatAreDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.Types.TypeSelector ThatAreInNamespace(string @namespace) { }
        public AwesomeAssertions.Types.TypeSelector ThatAreInterfaces() { }
        public AwesomeAssertions.Types.TypeSelector ThatAreNotAbstract() { }
        public AwesomeAssertions.Types.TypeSelector ThatAreNotClasses() { }
        public AwesomeAssertions.Types.TypeSelector ThatAreNotDecoratedWith<TAttribute>()
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.Types.TypeSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.Types.TypeSelector ThatAreNotInNamespace(string @namespace) { }
        public AwesomeAssertions.Types.TypeSelector ThatAreNotInterfaces() { }
        public AwesomeAssertions.Types.TypeSelector ThatAreNotSealed() { }
        public AwesomeAssertions.Types.TypeSelector ThatAreNotStatic() { }
        public AwesomeAssertions.Types.TypeSelector ThatAreNotUnderNamespace(string @namespace) { }
        public AwesomeAssertions.Types.TypeSelector ThatAreNotValueTypes() { }
        public AwesomeAssertions.Types.TypeSelector ThatAreSealed() { }
        public AwesomeAssertions.Types.TypeSelector ThatAreStatic() { }
        public AwesomeAssertions.Types.TypeSelector ThatAreUnderNamespace(string @namespace) { }
        public AwesomeAssertions.Types.TypeSelector ThatAreValueTypes() { }
        public AwesomeAssertions.Types.TypeSelector ThatDeriveFrom<TBase>() { }
        public AwesomeAssertions.Types.TypeSelector ThatDoNotDeriveFrom<TBase>() { }
        public AwesomeAssertions.Types.TypeSelector ThatDoNotHaveAccessModifier(AwesomeAssertions.Common.CSharpAccessModifier accessModifier) { }
        public AwesomeAssertions.Types.TypeSelector ThatDoNotImplement<TInterface>() { }
        public AwesomeAssertions.Types.TypeSelector ThatHaveAccessModifier(AwesomeAssertions.Common.CSharpAccessModifier accessModifier) { }
        public AwesomeAssertions.Types.TypeSelector ThatImplement<TInterface>() { }
        public AwesomeAssertions.Types.TypeSelector ThatSatisfy(System.Func<System.Type, bool> predicate) { }
        public System.Type[] ToArray() { }
        public AwesomeAssertions.Types.TypeSelector UnwrapEnumerableTypes() { }
        public AwesomeAssertions.Types.TypeSelector UnwrapTaskTypes() { }
    }
    public class TypeSelectorAssertions
    {
        public TypeSelectorAssertions(AwesomeAssertions.Execution.AssertionChain assertionChain, params System.Type[] types) { }
        public AwesomeAssertions.Execution.AssertionChain CurrentAssertionChain { get; }
        public System.Collections.Generic.IEnumerable<System.Type> Subject { get; }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> BeDecoratedWith<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> BeDecoratedWithOrInherit<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> BeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> BeInNamespace(string @namespace, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> BeSealed([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> BeUnderNamespace(string @namespace, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public override bool Equals(object obj) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWith<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWithOrInherit<TAttribute>([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs)
            where TAttribute : System.Attribute { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> NotBeInNamespace(string @namespace, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> NotBeSealed([System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Types.TypeSelectorAssertions> NotBeUnderNamespace(string @namespace, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
}
namespace AwesomeAssertions.Xml
{
    public class XAttributeAssertions : AwesomeAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XAttribute, AwesomeAssertions.Xml.XAttributeAssertions>
    {
        public XAttributeAssertions(System.Xml.Linq.XAttribute attribute, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XAttributeAssertions> Be(System.Xml.Linq.XAttribute expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XAttributeAssertions> HaveValue(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XAttributeAssertions> NotBe(System.Xml.Linq.XAttribute unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class XDocumentAssertions : AwesomeAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XDocument, AwesomeAssertions.Xml.XDocumentAssertions>
    {
        public XDocumentAssertions(System.Xml.Linq.XDocument document, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XDocumentAssertions> Be(System.Xml.Linq.XDocument expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XDocumentAssertions> BeEquivalentTo(System.Xml.Linq.XDocument expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElement(System.Xml.Linq.XName expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElement(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XDocumentAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(System.Xml.Linq.XName expected, AwesomeAssertions.OccurrenceConstraint occurrenceConstraint, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XDocumentAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(string expected, AwesomeAssertions.OccurrenceConstraint occurrenceConstraint, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElementWithValue(System.Xml.Linq.XName expectedElement, string expectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElementWithValue(string expectedElement, string expectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveRoot(System.Xml.Linq.XName expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveRoot(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XDocumentAssertions> NotBe(System.Xml.Linq.XDocument unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XDocumentAssertions> NotBeEquivalentTo(System.Xml.Linq.XDocument unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XDocumentAssertions> NotHaveElement(System.Xml.Linq.XName unexpectedElement, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XDocumentAssertions> NotHaveElement(string unexpectedElement, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XDocumentAssertions> NotHaveElementWithValue(System.Xml.Linq.XName unexpectedElement, string unexpectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XDocumentAssertions> NotHaveElementWithValue(string unexpectedElement, string unexpectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class XElementAssertions : AwesomeAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XElement, AwesomeAssertions.Xml.XElementAssertions>
    {
        public XElementAssertions(System.Xml.Linq.XElement xElement, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> Be(System.Xml.Linq.XElement expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> BeEquivalentTo(System.Xml.Linq.XElement expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> HaveAttribute(System.Xml.Linq.XName expectedName, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> HaveAttribute(string expectedName, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> HaveAttributeWithValue(System.Xml.Linq.XName expectedName, string expectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> HaveAttributeWithValue(string expectedName, string expectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElement(System.Xml.Linq.XName expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElement(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XElementAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(System.Xml.Linq.XName expected, AwesomeAssertions.OccurrenceConstraint occurrenceConstraint, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XElementAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(string expected, AwesomeAssertions.OccurrenceConstraint occurrenceConstraint, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElementWithValue(System.Xml.Linq.XName expectedElement, string expectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElementWithValue(string expectedElement, string expectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> HaveValue(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> NotBe(System.Xml.Linq.XElement unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> NotBeEquivalentTo(System.Xml.Linq.XElement unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> NotHaveAttribute(System.Xml.Linq.XName unexpectedName, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> NotHaveAttribute(string unexpectedName, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> NotHaveAttributeWithValue(System.Xml.Linq.XName unexpectedName, string unexpectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> NotHaveAttributeWithValue(string unexpectedName, string unexpectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> NotHaveElement(System.Xml.Linq.XName unexpectedElement, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> NotHaveElement(string unexpectedElement, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> NotHaveElementWithValue(System.Xml.Linq.XName unexpectedElement, string unexpectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XElementAssertions> NotHaveElementWithValue(string unexpectedElement, string unexpectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class XmlElementAssertions : AwesomeAssertions.Xml.XmlNodeAssertions<System.Xml.XmlElement, AwesomeAssertions.Xml.XmlElementAssertions>
    {
        public XmlElementAssertions(System.Xml.XmlElement xmlElement, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XmlElementAssertions> HaveAttribute(string expectedName, string expectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XmlElementAssertions> HaveAttributeWithNamespace(string expectedName, string expectedNamespace, string expectedValue, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XmlElementAssertions, System.Xml.XmlElement> HaveElement(string expectedName, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndWhichConstraint<AwesomeAssertions.Xml.XmlElementAssertions, System.Xml.XmlElement> HaveElementWithNamespace(string expectedName, string expectedNamespace, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<AwesomeAssertions.Xml.XmlElementAssertions> HaveInnerText(string expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class XmlNodeAssertions : AwesomeAssertions.Xml.XmlNodeAssertions<System.Xml.XmlNode, AwesomeAssertions.Xml.XmlNodeAssertions>
    {
        public XmlNodeAssertions(System.Xml.XmlNode xmlNode, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
    }
    public class XmlNodeAssertions<TSubject, TAssertions> : AwesomeAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>
        where TSubject : System.Xml.XmlNode
        where TAssertions : AwesomeAssertions.Xml.XmlNodeAssertions<TSubject, TAssertions>
    {
        public XmlNodeAssertions(TSubject xmlNode, AwesomeAssertions.Execution.AssertionChain assertionChain) { }
        protected override string Identifier { get; }
        public AwesomeAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Xml.XmlNode expected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
        public AwesomeAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(System.Xml.XmlNode unexpected, [System.Diagnostics.CodeAnalysis.StringSyntax("CompositeFormat")] string because = "", params object[] becauseArgs) { }
    }
    public class XmlNodeFormatter : AwesomeAssertions.Formatting.IValueFormatter
    {
        public XmlNodeFormatter() { }
        public bool CanHandle(object value) { }
        public void Format(object value, AwesomeAssertions.Formatting.FormattedObjectGraph formattedGraph, AwesomeAssertions.Formatting.FormattingContext context, AwesomeAssertions.Formatting.FormatChild formatChild) { }
    }
}